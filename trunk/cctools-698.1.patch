diff -U8 -N -r cctools-698.1.orig/Makefile.linux cctools-698.1/Makefile.linux
--- cctools-698.1.orig/Makefile.linux	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/Makefile.linux	2009-03-06 15:29:22.070609000 -0500
@@ -0,0 +1,2 @@
+all clean: libstuff ar as ld misc otool
+	@for i in $^ ; do $(MAKE) -C $${i} -f Makefile.linux $@ ; done
diff -U8 -N -r cctools-698.1.orig/ar/Makefile.linux cctools-698.1/ar/Makefile.linux
--- cctools-698.1.orig/ar/Makefile.linux	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/ar/Makefile.linux	2009-03-06 11:08:34.621916000 -0500
@@ -0,0 +1,29 @@
+NULL =
+
+CFILES = \
+	append.c \
+	ar.c \
+	archive.c \
+	contents.c \
+	delete.c \
+	extract.c \
+	misc.c \
+	move.c \
+	print.c \
+	replace.c \
+	strmode-fbsd.c \
+	$(NULL)
+COBJS = $(CFILES:.c=.o)
+
+XCFLAGS = -fno-builtin-round -D__LITTLE_ENDIAN__ -D__private_extern__='__attribute__((visibility("hidden")))' -I../include -I../../usr_include
+
+all: ar
+
+ar: $(COBJS)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+.c.o:
+	$(CC) $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+clean:
+	-rm -rf ar $(COBJS)
diff -U8 -N -r cctools-698.1.orig/ar/append.c cctools-698.1/ar/append.c
--- cctools-698.1.orig/ar/append.c	2003-08-12 20:02:19.000000000 -0400
+++ cctools-698.1/ar/append.c	2009-03-05 21:56:02.578718000 -0500
@@ -90,17 +90,17 @@
 {
 	int afd, fd, eval;
 	char *file;
 	CF cf;
 	struct stat sb;
 
 	afd = open_archive(O_CREAT|O_RDWR);
 	if (lseek(afd, (off_t)0, SEEK_END) == (off_t)-1)
-		error(archive);
+		ar_error(archive);
 
 	/* Read from disk, write to an archive; pad on write. */
 	SETCF(0, 0, afd, archive, WPAD);
 	for (eval = 0; (file = *argv++);) {
 		if ((fd = open(file, O_RDONLY)) < 0) {
 			warn("%s", file);
 			eval = 1;
 			continue;
diff -U8 -N -r cctools-698.1.orig/ar/ar.c cctools-698.1/ar/ar.c
--- cctools-698.1.orig/ar/ar.c	2006-04-28 19:41:59.000000000 -0400
+++ cctools-698.1/ar/ar.c	2009-03-06 17:31:38.826289000 -0500
@@ -271,17 +271,26 @@
 
 	/*
 	 * The default is to run ranlib(1) for UNIX conformance.  But if the -S
 	 * option is specified by the user we don't run it.
 	 */
 	if(run_ranlib){
 	    /* run ranlib -f or -q on the archive */
 	    reset_execute_list();
-	    add_execute_list("ranlib");
+
+	    /* Find ranlib in the same directory as ar. */
+	    char my_dir[PATH_MAX];
+	    readlink("/proc/self/exe", my_dir, sizeof(my_dir));
+	    char* last_slash = strrchr(my_dir, '/');
+	    *last_slash = '\0';
+	    char ranlib[PATH_MAX];
+	    snprintf(ranlib, sizeof(ranlib), "%s/ranlib", my_dir);
+
+	    add_execute_list(ranlib);
 	    if(options & AR_S)
 		add_execute_list("-f");
 	    else
 		add_execute_list("-q");
 	    add_execute_list(archive);
 	    if(execute_list(verbose) == 0){
 		(void)fprintf(stderr, "%s: internal ranlib command failed\n",
 			      progname);
diff -U8 -N -r cctools-698.1.orig/ar/archive.c cctools-698.1/ar/archive.c
--- cctools-698.1.orig/ar/archive.c	2004-11-12 15:16:56.000000000 -0500
+++ cctools-698.1/ar/archive.c	2009-03-06 17:22:41.114463000 -0500
@@ -78,16 +78,17 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 
 #include <mach-o/fat.h>
 
 #include "archive.h"
 #include "extern.h"
+#include "stuff/ofile.h"
 
 typedef struct ar_hdr HDR;
 static char hb[sizeof(HDR) + 1];	/* real header */
 
 int archive_opened_for_writing = 0;
 
 int
 open_archive(mode)
@@ -102,21 +103,21 @@
 		if ((fd = open(archive, mode, DEFFILEMODE)) >= 0) {
 			/* POSIX.2 puts create message on stderr. */
 			if (!(options & AR_C))
 				warnx("creating archive %s", archive);
 			created = 1;
 			goto opened;
 		}
 		if (errno != EEXIST)
-			error(archive);
+			ar_error(archive);
 		mode &= ~O_EXCL;
 	}
 	if ((fd = open(archive, mode, DEFFILEMODE)) < 0)
-		error(archive);
+		ar_error(archive);
 
 	/* 
 	 * Attempt to place a lock on the opened file - if we get an 
 	 * error then someone is already working on this library (or
 	 * it's going across NFS).
 	 */
 opened:
 	r = flock(fd, LOCK_EX|LOCK_NB);
@@ -137,58 +138,60 @@
 		case EROFS:
 		case EOVERFLOW:
 		case EFBIG:
 
 		/* Something bad happened  so no point in going on. */
 		case EISDIR:
 		case EDEADLK:
 		case ESTALE:
-			error(archive);
+			ar_error(archive);
 			break;
 
 		/* Locking is supported but we are out of resources right now */
 		case ENOLCK:
 
 		/* Locking seems to not be working */
 		case ENOTSUP:
 		case EHOSTUNREACH:
+#ifdef EBADRPC
 		case EBADRPC:
+#endif
 		default:
 			/* Filesystem does not support locking */
 			break;
 		}
 	}
 
 	/*
 	 * If not created, O_RDONLY|O_RDWR indicates that it has to be
 	 * in archive format.
 	 */
 	if (!created &&
 	    ((mode & O_ACCMODE) == O_RDONLY || (mode & O_ACCMODE) == O_RDWR)) {
 		if ((nr = read(fd, buf, SARMAG) != SARMAG)) {
 			if (nr >= 0)
 				badfmt();
-			error(archive);
+			ar_error(archive);
 		} else if (bcmp(buf, ARMAG, SARMAG)) {
 			unsigned long magic;
 			memcpy(&magic, buf, sizeof(unsigned long));
 #ifdef __BIG_ENDIAN__
 			if(magic == FAT_MAGIC)
 #endif /* __BIG_ENDIAN__ */
 #ifdef __LITTLE_ENDIAN__
 			if(magic == FAT_CIGAM)
 #endif /* __LITTLE_ENDIAN__ */
 				fprintf(stderr, "ar: %s is a fat file (use "
 					"libtool(1) or lipo(1) and ar(1) on "
 					"it)\n", archive);
 			badfmt();
 		}
 	} else if (write(fd, ARMAG, SARMAG) != SARMAG)
-		error(archive);
+		ar_error(archive);
 
 	if ((mode & O_ACCMODE) == O_RDWR)
 		archive_opened_for_writing = 1;
 
 	return (fd);
 }
 
 void
@@ -218,17 +221,17 @@
 	int len, nr;
 	char *p, buf[20];
 
 	nr = read(fd, hb, sizeof(HDR));
 	if (nr != sizeof(HDR)) {
 		if (!nr)
 			return (0);
 		if (nr < 0)
-			error(archive);
+			ar_error(archive);
 		badfmt();
 	}
 
 	hdr = (struct ar_hdr *)hb;
 	if (strncmp(hdr->ar_fmag, ARFMAG, sizeof(ARFMAG) - 1))
 		badfmt();
 
 	/* Convert the header into the internal format. */
@@ -251,17 +254,17 @@
 	 */
 	if (!bcmp(hdr->ar_name, AR_EFMT1, sizeof(AR_EFMT1) - 1)) {
 		chdr.lname = len = atoi(hdr->ar_name + sizeof(AR_EFMT1) - 1);
 		if (len <= 0 || len > MAXNAMLEN)
 			badfmt();
 		nr = read(fd, chdr.name, len);
 		if (nr != len) {
 			if (nr < 0)
-				error(archive);
+				ar_error(archive);
 			badfmt();
 		}
 		chdr.name[len] = 0;
 		chdr.size -= len;
 	} else {
 		chdr.lname = 0;
 		memmove(chdr.name, hdr->ar_name, sizeof(hdr->ar_name));
 
@@ -305,58 +308,58 @@
 		lname = strlen(name);
 		if (options & AR_TR) {
 			if (lname > OLDARMAXNAME) {
 				(void)fflush(stdout);
 				warnx("warning: %s truncated to %.*s",
 				    name, OLDARMAXNAME, name);
 				(void)fflush(stderr);
 			}
-			(void)sprintf(hb, HDR3, name, (long int)sb->st_mtimespec.tv_sec,
+			(void)sprintf(hb, HDR3, name, (long int)sb->st_mtime,
 			    (unsigned int)(u_short)sb->st_uid,
 			    (unsigned int)(u_short)sb->st_gid,
-			    sb->st_mode, sb->st_size, ARFMAG);
+			    sb->st_mode, (int64_t)sb->st_size, ARFMAG);
 			lname = 0;
 		} else if (lname > sizeof(hdr->ar_name) || strchr(name, ' '))
 			(void)sprintf(hb, HDR1, AR_EFMT1, (lname + 3) & ~3,
-			    (long int)sb->st_mtimespec.tv_sec,
+			    (long int)sb->st_mtime,
 			    (unsigned int)(u_short)sb->st_uid,
 			    (unsigned int)(u_short)sb->st_gid,
-			    sb->st_mode, sb->st_size + ((lname + 3) & ~3),
+			    sb->st_mode, (int64_t)sb->st_size + ((lname + 3) & ~3),
 			    ARFMAG);
 		else {
 			lname = 0;
-			(void)sprintf(hb, HDR2, name, (long int)sb->st_mtimespec.tv_sec,
+			(void)sprintf(hb, HDR2, name, (long int)sb->st_mtime,
 			    (unsigned int)(u_short)sb->st_uid,
 			    (unsigned int)(u_short)sb->st_gid,
-			    sb->st_mode, sb->st_size, ARFMAG);
+			    sb->st_mode, (int64_t)sb->st_size, ARFMAG);
 		}
 		size = sb->st_size;
 	} else {
 		lname = chdr.lname;
 		name = chdr.name;
 		size = chdr.size;
 	}
 
 	if (write(cfp->wfd, hb, sizeof(HDR)) != sizeof(HDR))
-		error(cfp->wname);
+		ar_error(cfp->wname);
 	/*
 	 * For Rhapsody if long names are used then the name is padded with
 	 * '\0's to a 4 byte size.  This keeps members on 4-byte boundaries
 	 * which is required for object files in archives.
 	 */
 	if (lname) {
 		if (write(cfp->wfd, name, lname) != (int)lname)
-			error(cfp->wname);
+			ar_error(cfp->wname);
 		already_written = lname;
 		if ((lname % 4) != 0) {
 			static char pad[3] = "\0\0\0";
 			if (write(cfp->wfd, pad, 4-(lname%4)) !=
 			    (int)(4-(lname%4)))
-				error(cfp->wname);
+				ar_error(cfp->wname);
 			already_written += 4 - (lname % 4);
 		}
 	}
 	copy_ar(cfp, size);
 	already_written = 0;
 }
 
 /*
@@ -390,41 +393,41 @@
 
 	from = cfp->rfd;
 	to = cfp->wfd;
 	sz = size;
 	while (sz && (nr = read(from, buf, MIN(sz, sizeof(buf)))) > 0) {
 		sz -= nr;
 		for (off = 0; off < nr; nr -= off, off += nw)
 			if ((nw = write(to, buf + off, nr)) < 0)
-				error(cfp->wname);
+				ar_error(cfp->wname);
 	}
 	if (sz) {
 		if (nr == 0)
 			badfmt();
-		error(cfp->rname);
+		ar_error(cfp->rname);
 	}
 
 	if (cfp->flags & RPAD && (size + chdr.lname) & 1 &&
 	    (nr = read(from, buf, 1)) != 1) {
 		if (nr == 0)
 			badfmt();
-		error(cfp->rname);
+		ar_error(cfp->rname);
 	}
 	if (cfp->flags & WPAD && (size + already_written) & 1 &&
 	    write(to, &pad, 1) != 1)
-		error(cfp->wname);
+		ar_error(cfp->wname);
 }
 
 /*
  * skip_arobj -
  *	Skip over an object -- taking care to skip the pad bytes.
  */
 void
 skip_arobj(fd)
 	int fd;
 {
 	off_t len;
 
 	len = chdr.size + ((chdr.size + chdr.lname) & 1);
 	if (lseek(fd, len, SEEK_CUR) == (off_t)-1)
-		error(archive);
+		ar_error(archive);
 }
diff -U8 -N -r cctools-698.1.orig/ar/contents.c cctools-698.1/ar/contents.c
--- cctools-698.1.orig/ar/contents.c	2003-08-12 20:02:29.000000000 -0400
+++ cctools-698.1/ar/contents.c	2009-03-06 17:23:00.800792000 -0500
@@ -70,17 +70,17 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 
 #include <ar.h>
 #include <dirent.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <string.h>
-#include <tzfile.h>
+#include <time.h>
 #include <unistd.h>
 
 #include "archive.h"
 #include "extern.h"
 
 /*
  * contents --
  *	Handles t[v] option - opens the archive and then reads headers,
@@ -99,17 +99,17 @@
 	for (all = !*argv; get_arobj(afd);) {
 		if (all)
 			file = chdr.name;
 		else if (!(file = files(argv)))
 			goto next;
 		if (options & AR_V) {
 			(void)strmode(chdr.mode, buf);
 			(void)printf("%s %6d/%-6d %8qd ",
-			    buf + 1, chdr.uid, chdr.gid, chdr.size);
+			    buf + 1, chdr.uid, chdr.gid, (int64_t)chdr.size);
 			tp = localtime(&chdr.date);
 			(void)strftime(buf, sizeof(buf), "%b %e %H:%M %Y", tp);
 			(void)printf("%s %s\n", buf, file);
 		} else
 			(void)printf("%s\n", file);
 		if (!all && !*argv)
 			break;
 next:		skip_arobj(afd);
diff -U8 -N -r cctools-698.1.orig/ar/extern.h cctools-698.1/ar/extern.h
--- cctools-698.1.orig/ar/extern.h	2003-08-12 20:02:34.000000000 -0400
+++ cctools-698.1/ar/extern.h	2009-03-05 21:55:43.884259000 -0500
@@ -58,17 +58,17 @@
  *	@(#)extern.h	8.3 (Berkeley) 4/2/94
  */
 
 int	append __P((char **));
 void	badfmt __P((void));
 int	compare __P((char *));
 int	contents __P((char **));
 int	delete __P((char **));
-void	error __P((char *));
+void	ar_error __P((char *));
 int	extract __P((char **));
 char   *files __P((char **argv));
 int	move __P((char **));
 void	orphans __P((char **argv));
 int	print __P((char **));
 int	replace __P((char **));
 char   *rname __P((char *));
 int	tmp __P((void));
diff -U8 -N -r cctools-698.1.orig/ar/misc.c cctools-698.1/ar/misc.c
--- cctools-698.1.orig/ar/misc.c	2003-08-12 20:02:39.000000000 -0400
+++ cctools-698.1/ar/misc.c	2009-03-05 21:55:34.468667000 -0500
@@ -100,17 +100,17 @@
 	if (envtmp)
 		(void)sprintf(path, "%s/%s", envtmp, _NAME_ARTMP);
 	else
 		strcpy(path, _PATH_ARTMP);
 	
 	sigfillset(&set);
 	(void)sigprocmask(SIG_BLOCK, &set, &oset);
 	if ((fd = mkstemp(path)) == -1)
-		error(tname);
+		ar_error(tname);
         (void)unlink(path);
 	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
 	return (fd);
 }
 
 /*
  * files --
  *	See if the current file matches any file in the argument list; if it
@@ -159,19 +159,19 @@
 		return (!strncmp(chdr.name, rname(dest), OLDARMAXNAME));
 	return (!strcmp(chdr.name, rname(dest)));
 }
 
 void
 badfmt()
 {
 
-	errno = EFTYPE;
+	errno = EINVAL;
 	err(1, "%s", archive);
 }
 
 void
-error(name)
+ar_error(name)
 	char *name;
 {
 
 	err(1, "%s", name);
 }
diff -U8 -N -r cctools-698.1.orig/ar/strmode-fbsd.c cctools-698.1/ar/strmode-fbsd.c
--- cctools-698.1.orig/ar/strmode-fbsd.c	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/ar/strmode-fbsd.c	2009-03-05 22:14:02.328908000 -0500
@@ -0,0 +1,154 @@
+/* Libc-498.1.1/string/strmode-fbsd.c */
+/*-
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)strmode.c	8.3 (Berkeley) 8/15/94";
+#endif /* LIBC_SCCS and not lint */
+#include <sys/cdefs.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <string.h>
+
+void
+strmode(mode, p)
+	mode_t mode;
+	char *p;
+{
+	 /* print type */
+	switch (mode & S_IFMT) {
+	case S_IFDIR:			/* directory */
+		*p++ = 'd';
+		break;
+	case S_IFCHR:			/* character special */
+		*p++ = 'c';
+		break;
+	case S_IFBLK:			/* block special */
+		*p++ = 'b';
+		break;
+	case S_IFREG:			/* regular */
+		*p++ = '-';
+		break;
+	case S_IFLNK:			/* symbolic link */
+		*p++ = 'l';
+		break;
+	case S_IFSOCK:			/* socket */
+		*p++ = 's';
+		break;
+#ifdef S_IFIFO
+	case S_IFIFO:			/* fifo */
+		*p++ = 'p';
+		break;
+#endif
+#ifdef S_IFWHT
+	case S_IFWHT:			/* whiteout */
+		*p++ = 'w';
+		break;
+#endif
+	default:			/* unknown */
+		*p++ = '?';
+		break;
+	}
+	/* usr */
+	if (mode & S_IRUSR)
+		*p++ = 'r';
+	else
+		*p++ = '-';
+	if (mode & S_IWUSR)
+		*p++ = 'w';
+	else
+		*p++ = '-';
+	switch (mode & (S_IXUSR | S_ISUID)) {
+	case 0:
+		*p++ = '-';
+		break;
+	case S_IXUSR:
+		*p++ = 'x';
+		break;
+	case S_ISUID:
+		*p++ = 'S';
+		break;
+	case S_IXUSR | S_ISUID:
+		*p++ = 's';
+		break;
+	}
+	/* group */
+	if (mode & S_IRGRP)
+		*p++ = 'r';
+	else
+		*p++ = '-';
+	if (mode & S_IWGRP)
+		*p++ = 'w';
+	else
+		*p++ = '-';
+	switch (mode & (S_IXGRP | S_ISGID)) {
+	case 0:
+		*p++ = '-';
+		break;
+	case S_IXGRP:
+		*p++ = 'x';
+		break;
+	case S_ISGID:
+		*p++ = 'S';
+		break;
+	case S_IXGRP | S_ISGID:
+		*p++ = 's';
+		break;
+	}
+	/* other */
+	if (mode & S_IROTH)
+		*p++ = 'r';
+	else
+		*p++ = '-';
+	if (mode & S_IWOTH)
+		*p++ = 'w';
+	else
+		*p++ = '-';
+	switch (mode & (S_IXOTH | S_ISVTX)) {
+	case 0:
+		*p++ = '-';
+		break;
+	case S_IXOTH:
+		*p++ = 'x';
+		break;
+	case S_ISVTX:
+		*p++ = 'T';
+		break;
+	case S_IXOTH | S_ISVTX:
+		*p++ = 't';
+		break;
+	}
+	*p++ = ' ';		/* will be a '+' if ACL's implemented */
+	*p = '\0';
+}
diff -U8 -N -r cctools-698.1.orig/as/Makefile.linux cctools-698.1/as/Makefile.linux
--- cctools-698.1.orig/as/Makefile.linux	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/as/Makefile.linux	2009-03-06 12:58:17.715608000 -0500
@@ -0,0 +1,89 @@
+NULL =
+
+CFILES = \
+	app.c \
+	as.c \
+	atof-generic.c \
+	atof-ieee.c \
+	expr.c \
+	fixes.c \
+	flonum-const.c \
+	flonum-copy.c \
+	flonum-mult.c \
+	frags.c \
+	hash.c \
+	hex-value.c \
+	input-file.c \
+	input-scrub.c \
+	layout.c \
+	messages.c \
+	obstack.c \
+	read.c \
+	sections.c \
+	symbols.c \
+	write_object.c \
+	xmalloc.c \
+	$(NULL)
+
+CFILES_driver = driver.c
+COBJS_driver = $(CFILES_driver:%.c=bin/%.o)
+
+ARCH_DIR=libexec/gcc/darwin
+
+CFILES_i386 = $(CFILES) i386.c
+COBJS_i386 = $(CFILES_i386:%.c=$(ARCH_DIR)/i386/%.o)
+
+CFILES_x86_64 = $(CFILES_i386)
+COBJS_x86_64 = $(CFILES_x86_64:%.c=$(ARCH_DIR)/x86_64/%.o)
+
+CFILES_ppc = $(CFILES) ppc.c
+COBJS_ppc = $(CFILES_ppc:%.c=$(ARCH_DIR)/ppc/%.o)
+
+CFILES_ppc64 = $(CFILES_ppc)
+COBJS_ppc64 = $(CFILES_ppc64:%.c=$(ARCH_DIR)/ppc64/%.o)
+
+XCFLAGS = -fno-builtin-round -D__LITTLE_ENDIAN__ -D__private_extern__='__attribute__((visibility("hidden")))' -DNeXT_MOD -I../include -I../../usr_include
+
+all: bin/as \
+     $(ARCH_DIR)/i386/as \
+     $(ARCH_DIR)/x86_64/as \
+     $(ARCH_DIR)/ppc/as \
+     $(ARCH_DIR)/ppc64/as
+
+bin/as: $(COBJS_driver)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+$(COBJS_driver): bin/%.o: %.c
+	@mkdir -p $(@D)
+	$(CC) $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+$(ARCH_DIR)/i386/as: $(COBJS_i386)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+$(COBJS_i386): $(ARCH_DIR)/i386/%.o: %.c
+	@mkdir -p $(@D)
+	$(CC) $(CFLAGS) $(XCFLAGS) -DI386 -c -o $@ $<
+
+$(ARCH_DIR)/x86_64/as: $(COBJS_x86_64)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+$(COBJS_x86_64): $(ARCH_DIR)/x86_64/%.o: %.c
+	@mkdir -p $(@D)
+	$(CC) $(CFLAGS) $(XCFLAGS) -DI386 -DARCH64 -c -o $@ $<
+
+$(ARCH_DIR)/ppc/as: $(COBJS_ppc)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+$(COBJS_ppc): $(ARCH_DIR)/ppc/%.o: %.c
+	@mkdir -p $(@D)
+	$(CC) $(CFLAGS) $(XCFLAGS) -DPPC -c -o $@ $<
+
+$(ARCH_DIR)/ppc64/as: $(COBJS_ppc64)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+$(COBJS_ppc64): $(ARCH_DIR)/ppc64/%.o: %.c
+	@mkdir -p $(@D)
+	$(CC) $(CFLAGS) $(XCFLAGS) -DPPC -DARCH64 -c -o $@ $<
+
+clean:
+	-rm -rf bin libexec
diff -U8 -N -r cctools-698.1.orig/as/driver.c cctools-698.1/as/driver.c
--- cctools-698.1.orig/as/driver.c	2006-11-17 18:03:01.000000000 -0500
+++ cctools-698.1/as/driver.c	2009-03-06 11:12:36.530920000 -0500
@@ -42,33 +42,27 @@
 		    "../local/libexec/gcc/darwin/";
 #endif
     const char *AS = "/as";
 
     int i;
     unsigned long count, verbose;
     char *p, c, *arch_name, *as, *as_local;
     char *prefix, buf[MAXPATHLEN], resolved_name[PATH_MAX];
-    uint32_t bufsize;
     struct arch_flag arch_flag;
     const struct arch_flag *arch_flags, *family_arch_flag;
 
 	progname = argv[0];
 	arch_name = NULL;
 	verbose = 0;
 	/*
 	 * Construct the prefix to the assembler driver.
 	 */
-	bufsize = MAXPATHLEN;
 	p = buf;
-	i = _NSGetExecutablePath(p, &bufsize);
-	if(i == -1){
-	    p = allocate(bufsize);
-	    _NSGetExecutablePath(p, &bufsize);
-	}
+	readlink("/proc/self/exe", buf, sizeof(buf));
 	prefix = realpath(p, resolved_name);
 	p = rindex(prefix, '/');
 	if(p != NULL)
 	    p[1] = '\0';
 	/*
 	 * Process the assembler flags exactly like the assembler would (except
 	 * let the assembler complain about multiple flags, bad combinations of
 	 * flags, unknown single letter flags and the like).  The main thing
diff -U8 -N -r cctools-698.1.orig/as/input-scrub.c cctools-698.1/as/input-scrub.c
--- cctools-698.1.orig/as/input-scrub.c	2006-04-28 19:51:56.000000000 -0400
+++ cctools-698.1/as/input-scrub.c	2009-03-06 01:12:41.472668000 -0500
@@ -319,16 +319,17 @@
       if (input_file_is_open())
 	{			/* we can still read lines from source */
 	   *line_ret = logical_input_line ?
 		       logical_input_line : physical_input_line;
 	}
     }
 }
 
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 /*
  * as_where_ProjectBuilder() returns the fileName, directory, and line number
  * to be used to tell ProjectBuilder where the error is.  Note that the '/'
  * between fileName and directory does not appear in what is returned.
  */
 void
 as_where_ProjectBuilder(
 char **fileName,
@@ -353,39 +354,32 @@
 	    *fileName = p;
 	    q = strrchr(p, '/');
 	    if(q == NULL)
 		return;
 	    *fileName = p + 1;
 	    strncat(directory_buf, p, q - p);
 	}
 }
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 
 /*
  *			a s _ p e r r o r
  *
  * Like perror(3), but with more info.
  */
 void
 as_perror(
 char *gripe,		/* Unpunctuated error theme. */
 char *filename)
 {
   fprintf (stderr,"as:file(%s) %s! ",
 	   filename, gripe
 	   );
-  if (errno > sys_nerr)
-    {
-      fprintf (stderr, "Unknown error #%d.", errno);
-    }
-  else
-    {
-      fprintf (stderr, "%s.", sys_errlist [errno]);
-    }
-  (void)putc('\n', stderr);
+  fprintf(stderr, "%s.\n", strerror(errno));
   errno = 0;			/* After reporting, clear it. */
   if (input_file_is_open())	/* RMS says don't mention line # if not needed. */
     {
       as_where();
     }
   bad_error = 1;
 }
 
diff -U8 -N -r cctools-698.1.orig/as/input-scrub.h cctools-698.1/as/input-scrub.h
--- cctools-698.1.orig/as/input-scrub.h	2002-11-27 20:01:17.000000000 -0500
+++ cctools-698.1/as/input-scrub.h	2009-03-06 01:12:50.806389000 -0500
@@ -23,20 +23,22 @@
 extern void new_logical_line(
     char *fname,
     int line_number);
 extern void as_where(
     void);
 extern void as_file_and_line(
     char **file_ret,
     unsigned int *line_ret);
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 extern void as_where_ProjectBuilder(
     char **fileName,
     char **directory,
     int *line);
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 extern void as_perror(
     char *gripe,
     char *filename);
 
 /* Sanitising things. */
 extern void input_scrub_begin(
     void);
 extern void input_scrub_end(
diff -U8 -N -r cctools-698.1.orig/as/messages.c cctools-698.1/as/messages.c
--- cctools-698.1.orig/as/messages.c	2008-02-04 17:27:50.000000000 -0500
+++ cctools-698.1/as/messages.c	2009-03-06 00:10:30.459903000 -0500
@@ -17,25 +17,22 @@
 along with GAS; see the file COPYING.  If not, write to
 the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #include <stdio.h>
 #include <stdarg.h>
 #ifdef OLD_PROJECTBUILDER_INTERFACE
 #include <streams/streams.h>
 #endif
-#include "make.h"
 #include <stdlib.h>
 #include <string.h>
 #include <mach/mach.h>
 #include <mach/mach_init.h>
 #if defined(__OPENSTEP__) || defined(__GONZO_BUNSEN_BEAKER__)
 #include <servers/netname.h>
-#else
-#include <servers/bootstrap.h>
 #endif
 #include "as.h"
 #include "input-scrub.h"
 #include "messages.h"
 
 /*
 		ERRORS
 
diff -U8 -N -r cctools-698.1.orig/as/sections.c cctools-698.1/as/sections.c
--- cctools-698.1.orig/as/sections.c	2007-06-05 21:00:46.000000000 -0400
+++ cctools-698.1/as/sections.c	2009-03-05 22:33:09.786179000 -0500
@@ -19,16 +19,17 @@
 
 /* FROM line 25 */
 #include "as.h"
 
 /*
  * Mach-O sections are chains of fragments.
  */
 #include <stdlib.h>
+#include <string.h>
 #include <strings.h>
 #include "sections.h"
 #include "obstack.h"
 #include "xmalloc.h"
 #include "frags.h"
 #include "messages.h"
 
 /*
diff -U8 -N -r cctools-698.1.orig/include/mach-o/dyld.h cctools-698.1/include/mach-o/dyld.h
--- cctools-698.1.orig/include/mach-o/dyld.h	2004-10-19 16:59:34.000000000 -0400
+++ cctools-698.1/include/mach-o/dyld.h	2009-03-05 22:25:03.610708000 -0500
@@ -27,20 +27,16 @@
 extern "C" {
 #endif /* __cplusplus */
 
 #if defined(__MWERKS__) && !defined(__private_extern__)
 #define __private_extern__ __declspec(private_extern)
 #endif
 
 #include <mach-o/loader.h>
-#include <AvailabilityMacros.h>
-#ifndef AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
-#define AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER
-#endif
 
 #ifndef ENUM_DYLD_BOOL
 #define ENUM_DYLD_BOOL
 #undef FALSE
 #undef TRUE
 enum DYLD_BOOL {
     FALSE,
     TRUE
@@ -103,18 +99,17 @@
     const char *symbolName);
 extern void * NSGetSectionDataInObjectFileImage(
     NSObjectFileImage objectFileImage,
     const char *segmentName,
     const char *sectionName,
     unsigned long *size); /* can be NULL */
 /* SPI first appeared in Mac OS X 10.3 */
 extern enum DYLD_BOOL NSHasModInitObjectFileImage(
-    NSObjectFileImage objectFileImage)
-    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;
+    NSObjectFileImage objectFileImage);
 
 /* module API */
 typedef void * NSModule;
 extern const char * NSNameOfModule(
     NSModule m); 
 extern const char * NSLibraryNameForModule(
     NSModule m);
 
@@ -281,27 +276,25 @@
 extern void _dyld_bind_objc_module(
     void *objc_module);
 extern enum DYLD_BOOL _dyld_bind_fully_image_containing_address(
     unsigned long *address);
 extern enum DYLD_BOOL _dyld_image_containing_address(
     unsigned long address);
 /* SPI first appeared in Mac OS X 10.3 */
 extern struct mach_header * _dyld_get_image_header_containing_address(
-    unsigned long address)
-    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;
+    unsigned long address);
 
 extern void _dyld_moninit(
     void (*monaddition)(char *lowpc, char *highpc));
 extern enum DYLD_BOOL _dyld_launched_prebound(
     void);
 /* SPI first appeared in Mac OS X 10.3 */
 extern enum DYLD_BOOL _dyld_all_twolevel_modules_prebound(
-    void)
-    AVAILABLE_MAC_OS_X_VERSION_10_3_AND_LATER;
+    void);
 
 extern void _dyld_lookup_and_bind(
     const char *symbol_name,
     unsigned long *address,
     void **module);
 extern void _dyld_lookup_and_bind_with_hint(
     const char *symbol_name,
     const char *library_name_hint,
diff -U8 -N -r cctools-698.1.orig/include/stuff/bytesex.h cctools-698.1/include/stuff/bytesex.h
--- cctools-698.1.orig/include/stuff/bytesex.h	2008-03-27 20:49:09.000000000 -0400
+++ cctools-698.1/include/stuff/bytesex.h	2009-03-05 21:17:56.720746000 -0500
@@ -229,17 +229,17 @@
 
 __private_extern__ void swap_i386_thread_state(
     i386_thread_state_t *cpu,
     enum byte_sex target_byte_sex);
 
 /* current i386 thread states */
 #if i386_THREAD_STATE == 1
 __private_extern__ void swap_i386_float_state(
-    struct __darwin_i386_float_state *fpu,
+    i386_float_state_t *fpu,
     enum byte_sex target_byte_sex);
 
 __private_extern__ void swap_i386_exception_state(
     i386_exception_state_t *exc,
     enum byte_sex target_byte_sex);
 #endif /* i386_THREAD_STATE == 1 */
 
 /* i386 thread states on older releases */
diff -U8 -N -r cctools-698.1.orig/include/stuff/emulated.h cctools-698.1/include/stuff/emulated.h
--- cctools-698.1.orig/include/stuff/emulated.h	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/include/stuff/emulated.h	2009-03-06 01:00:47.710190000 -0500
@@ -0,0 +1,7 @@
+#ifndef _STUFF_EMULATED_H
+#define _STUFF_EMULATED_H
+
+void qsort_r(void*, size_t, size_t, void*,
+             int(*)(void*, const void*, const void*));
+
+#endif /* _STUFF_EMULATED_H */
diff -U8 -N -r cctools-698.1.orig/include/stuff/macosx_deployment_target.h cctools-698.1/include/stuff/macosx_deployment_target.h
--- cctools-698.1.orig/include/stuff/macosx_deployment_target.h	2007-04-25 19:57:49.000000000 -0400
+++ cctools-698.1/include/stuff/macosx_deployment_target.h	2009-03-06 00:56:06.093503000 -0500
@@ -15,21 +15,26 @@
  * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
  * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
  * Please see the License for the specific language governing rights and
  * limitations under the License.
  * 
  * @APPLE_LICENSE_HEADER_END@
  */
+#ifndef _STUFF_MACOSX_DEPLOYMENT_TARGET_H_
+#define _STUFF_MACOSX_DEPLOYMENT_TARGET_H_
+
 #include <mach/mach.h>
 
 struct macosx_deployment_target {
     unsigned long major;	/* major version */
     unsigned long minor;	/* minor version (if any or zero) */
     char *name;			/* name for printing */
 };
 
 __private_extern__ void get_macosx_deployment_target(
     struct macosx_deployment_target *value);
 
 __private_extern__ void put_macosx_deployment_target(
     char *target);
+
+#endif /* _STUFF_MACOSX_DEPLOYMENT_TARGET_H_ */
diff -U8 -N -r cctools-698.1.orig/ld/Makefile.linux cctools-698.1/ld/Makefile.linux
--- cctools-698.1.orig/ld/Makefile.linux	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/ld/Makefile.linux	2009-03-06 12:58:22.354909000 -0500
@@ -0,0 +1,47 @@
+NULL =
+
+CFILES = \
+	4byte_literals.c \
+	8byte_literals.c \
+	arm_reloc.c \
+	coalesced_sections.c \
+	cstring_literals.c \
+	debugcompunit.c \
+	debugline.c \
+	dylibs.c \
+	fvmlibs.c \
+	generic_reloc.c \
+	hppa_reloc.c \
+	i860_reloc.c \
+	indirect_sections.c \
+	layout.c \
+	ld.c \
+	literal_pointers.c \
+	m88k_reloc.c \
+	mod_sections.c \
+	objects.c \
+	pass1.c \
+	pass2.c \
+	ppc_reloc.c \
+	rld.c \
+	sections.c \
+	sets.c \
+	sparc_reloc.c \
+	specs.c \
+	symbols.c \
+	uuid.c \
+	$(NULL)
+COBJS = $(CFILES:.c=.o)
+
+XCFLAGS = -fno-builtin-round -D__LITTLE_ENDIAN__ -D__private_extern__='__attribute__((visibility("hidden")))' -I../include -I../../usr_include
+
+all: ld_classic
+
+ld_classic: $(COBJS)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+.c.o:
+	$(CC) $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+clean:
+	-rm -rf ld_classic $(COBJS)
diff -U8 -N -r cctools-698.1.orig/ld/ld.c cctools-698.1/ld/ld.c
--- cctools-698.1.orig/ld/ld.c	2008-02-04 17:28:55.000000000 -0500
+++ cctools-698.1/ld/ld.c	2009-03-06 01:15:18.775545000 -0500
@@ -50,22 +50,19 @@
 #include <libc.h>
 #include <ar.h>
 #include <mach/mach.h>
 #include <mach/mach_error.h>
 #include "stuff/seg_addr_table.h"
 #ifndef RLD
 #include "stuff/symbol_list.h"
 #endif
-#include "make.h"
 #include <mach/mach_init.h>
 #if defined(__OPENSTEP__) || defined(__GONZO_BUNSEN_BEAKER__)
 #include <servers/netname.h>
-#else
-#include <servers/bootstrap.h>
 #endif
 #else /* defined(KLD) && defined(__STATIC__) */
 #include <mach/mach.h>
 #include <mach/kern_return.h>
 #endif /* !(defined(KLD) && defined(__STATIC__)) */
 
 #include "ld.h"
 #ifndef RLD
@@ -453,17 +450,19 @@
 static void cleanup(void);
 static void ld_exit(int exit_value);
 
 /*
  * This is for the ProjectBuilder (formally MakeApp) interface.
  */
 static int talking_to_ProjectBuilder = 0;
 static mach_port_t ProjectBuilder_port;
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 static void check_for_ProjectBuilder(void);
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 
 /* The signal hander routine for SIGINT, SIGTERM, SIGBUS & SIGSEGV */
 static void handler(int sig);
 
 /* Static routines to help parse arguments */
 static enum bool ispoweroftwo(unsigned long x);
 static vm_prot_t getprot(char *prot, char **endp);
 static enum bool check_max_init_prot(vm_prot_t maxprot, vm_prot_t initprot);
@@ -539,18 +538,20 @@
 	    signal(SIGINT, handler);
 	if(signal(SIGTERM, SIG_IGN) != SIG_IGN)
 	    signal(SIGTERM, handler);
 	if(signal(SIGBUS, SIG_IGN) != SIG_IGN)
 	    signal(SIGBUS, handler);
 	if(signal(SIGSEGV, SIG_IGN) != SIG_IGN)
 	    signal(SIGSEGV, handler);
 
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 	/* If ProjectBuilder is around set up for it */
 	check_for_ProjectBuilder();
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 
 	/* This needs to be here so that we test the environment variable before
 	   the rest of options parsing.  */
 	if (getenv("LD_PRINT_OPTIONS") != NULL)
 	  ld_print_options = TRUE;
 
 	/*
 	 * Parse the command line options in this pass and skip the object files
@@ -3316,16 +3317,17 @@
 {
 	if(((initprot & VM_PROT_READ)    && !(maxprot & VM_PROT_READ)) ||
 	   ((initprot & VM_PROT_WRITE)   && !(maxprot & VM_PROT_WRITE)) ||
 	   ((initprot & VM_PROT_EXECUTE) && !(maxprot & VM_PROT_EXECUTE)) )
 	return(FALSE);
 	return(TRUE);
 }
 
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 /*
  * check_for_ProjectBuilder() is called once before any error messages are
  * generated and sets up what is needed to send error messages to project
  * builder.
  */
 static
 void
 check_for_ProjectBuilder(void)
@@ -3367,16 +3369,24 @@
 	make_alert(ProjectBuilder_port,
 	    2, /* eventType */
 	    NULL, 0, /* functionName, not used by ProjectBuilder */
 	    NULL, 0, /* fileName */
 	    NULL, 0, /* directory */
 	    0, /* line */
 	    message, strlen(message)+1 > 1024 ? 1024 : strlen(message)+1);
 }
+#else
+__private_extern__
+void
+tell_ProjectBuilder(
+char *message)
+{
+}
+#endif  /* OLD_PROJECTBUILDER_INTERFACE */
 
 /*
  * ld_exit() is use for all exit()s from the link editor.
  */
 static
 void
 ld_exit(
 int exit_value)
diff -U8 -N -r cctools-698.1.orig/ld/ld.h cctools-698.1/ld/ld.h
--- cctools-698.1.orig/ld/ld.h	2007-04-25 19:56:58.000000000 -0400
+++ cctools-698.1/ld/ld.h	2009-03-06 01:06:00.229201000 -0500
@@ -19,16 +19,19 @@
  * limitations under the License.
  *
  * @APPLE_LICENSE_HEADER_END@
  */
 #if defined(__MWERKS__) && !defined(__private_extern__)
 #define __private_extern__ __declspec(private_extern)
 #endif
 
+#include "stuff/arch.h"
+#include "stuff/macosx_deployment_target.h"
+
 /*
  * Global types, variables and routines declared in the file ld.c.
  *
  * The following include file need to be included before this file:
  * #include <sys/loader.h>
  * #include <mach.h>
  * #include <stdarg.h>  (included in <stdio.h>)
  */
diff -U8 -N -r cctools-698.1.orig/ld/pass1.c cctools-698.1/ld/pass1.c
--- cctools-698.1.orig/ld/pass1.c	2007-09-07 20:51:28.000000000 -0400
+++ cctools-698.1/ld/pass1.c	2009-03-06 01:01:26.183844000 -0500
@@ -53,16 +53,17 @@
 #endif /* !(defined(KLD) && defined(__STATIC__)) */
 #include <ar.h>
 #ifndef AR_EFMT1
 #define	AR_EFMT1	"#1/"		/* extended format #1 */
 #endif
 #include <mach-o/ranlib.h>
 #include "stuff/arch.h"
 #include "stuff/best_arch.h"
+#include "stuff/emulated.h"
 #include "stuff/guess_short_name.h"
 #include "stuff/macosx_deployment_target.h"
 
 #include "ld.h"
 #include "pass1.h"
 #include "live_refs.h"
 #include "objects.h"
 #include "fvmlibs.h"
diff -U8 -N -r cctools-698.1.orig/ld/symbols.c cctools-698.1/ld/symbols.c
--- cctools-698.1.orig/ld/symbols.c	2008-02-04 17:29:09.000000000 -0500
+++ cctools-698.1/ld/symbols.c	2009-03-06 01:02:05.883198000 -0500
@@ -4595,18 +4595,18 @@
 		       merged_symbol->nlist.n_type == (N_EXT | N_PBUD))
 			continue;
 		    if((merged_symbol->nlist.n_type & N_EXT) &&
 		       (merged_symbol->nlist.n_type & N_PEXT))
 			continue;
 		    if(only_referenced_dynamically == TRUE)
 			continue;
 		}
-#ifdef DEBUG
 mark_it_live:
+#ifdef DEBUG
 		if(((debug & (1 << 25)) || (debug & (1 << 26)))){
 		    print("** In mark_globals_live() ");
 		    if(merged_symbol->nlist.n_desc & N_NO_DEAD_STRIP)
 			print("no dead strip symbol ");
 		    else
 			print("exported symbol ");
 		    print_obj_name(merged_symbol->definition_object);
 		    print("%s\n", merged_symbol->nlist.n_un.n_name);
diff -U8 -N -r cctools-698.1.orig/ld/uuid.c cctools-698.1/ld/uuid.c
--- cctools-698.1.orig/ld/uuid.c	2007-06-05 21:00:47.000000000 -0400
+++ cctools-698.1/ld/uuid.c	2009-03-06 01:11:28.034955000 -0500
@@ -23,24 +23,24 @@
 #if defined(__MWERKS__) && !defined(__private_extern__)
 #define __private_extern__ __declspec(private_extern)
 #endif
 
 #include <sys/types.h>
 #include <string.h>
 #include <stdarg.h>
 #include <mach/mach.h>
+#include "ld.h"
 #include <mach-o/loader.h>
 #if !(defined(KLD) && defined(__STATIC__))
 #include <sys/uio.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <mach-o/dyld.h>
 #endif /* !(defined(KLD) && defined(__STATIC__)) */
-#include "ld.h"
 #include <stdlib.h>
 
 /*
  * uuid() is called to set the uuid[] bytes for the uuid load command.
  */
 __private_extern__
 void
 uuid(
@@ -54,25 +54,29 @@
     ssize_t n;
 
 	/*
 	 * We would like to just #include <uuid/uuid.h> and but that header
 	 * file did not exist on system until Mac OS 10.4 .  So instead we
 	 * dynamically lookup uuid_generate_random() and if it is defined we
 	 * call it indirectly.
 	 */
+#if 0
 	if(NSIsSymbolNameDefined("_uuid_generate_random")){
 	    nssymbol = (void *)NSLookupAndBindSymbol("_uuid_generate_random");
 	    uuid_func = NSAddressOfSymbol(nssymbol);
 	    uuid_func(uuid);
 	}
 	/*
 	 * Since we don't have uuid_generate() just read bytes from /dev/urandom
 	 */
-	else{
+	else
+#else
+        {
+#endif
 	    fd = open("/dev/urandom", O_RDONLY, 0);
 	    if(fd == -1){
 		system_warning("can't open: /dev/urandom to fill in uuid load "
 		    "command (using bytes of zero)");
 		memset(uuid, '\0', sizeof(u.uuid));
 	    }
 	    else{
 		n = read(fd, uuid, sizeof(u.uuid));
diff -U8 -N -r cctools-698.1.orig/libstuff/Makefile.linux cctools-698.1/libstuff/Makefile.linux
--- cctools-698.1.orig/libstuff/Makefile.linux	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/libstuff/Makefile.linux	2009-03-06 14:41:28.178385000 -0500
@@ -0,0 +1,57 @@
+NULL =
+
+CFILES = \
+	SymLoc.c \
+	allocate.c \
+	apple_version.c \
+	arch.c \
+	arch_usage.c \
+	best_arch.c \
+	breakout.c \
+	bytesex.c \
+	checkout.c \
+	coff_bytesex.c \
+	crc32.c \
+	dylib_roots.c \
+	dylib_table.c \
+	emulated.c \
+	errors.c \
+	execute.c \
+	fatal_arch.c \
+	fatals.c \
+	get_arch_from_host.c \
+	get_toc_byte_sex.c \
+	guess_short_name.c \
+	hash_string.c \
+	hppa.c \
+	lto.c \
+	macosx_deployment_target.c \
+	ofile.c \
+	ofile_error.c \
+	ofile_get_word.c \
+	print.c \
+	reloc.c \
+	round.c \
+	seg_addr_table.c \
+	set_arch_flag_name.c \
+	swap_headers.c \
+	symbol_list.c \
+	unix_standard_mode.c \
+	version_number.c \
+	vm_flush_cache.c \
+	writeout.c \
+	$(NULL)
+COBJS = $(CFILES:.c=.o)
+
+XCFLAGS = -fno-builtin-round -D__LITTLE_ENDIAN__ -D__private_extern__='__attribute__((visibility("hidden")))' -DEMULATED_HOST_CPU_TYPE=CPU_TYPE_I386 -DEMULATED_HOST_CPU_SUBTYPE='CPU_SUBTYPE_INTEL(12, 1)' -I../include -I../../usr_include
+
+all: libstuff.a
+
+libstuff.a: $(COBJS)
+	$(AR) cr $@ $^
+
+.c.o:
+	$(CC) $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+clean:
+	-rm -rf libstuff.a $(COBJS)
diff -U8 -N -r cctools-698.1.orig/libstuff/apple_version.c cctools-698.1/libstuff/apple_version.c
--- cctools-698.1.orig/libstuff/apple_version.c	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/libstuff/apple_version.c	2009-03-05 22:50:03.140488000 -0500
@@ -0,0 +1 @@
+const char apple_version[]= "cctools-698.1";
diff -U8 -N -r cctools-698.1.orig/libstuff/emulated.c cctools-698.1/libstuff/emulated.c
--- cctools-698.1.orig/libstuff/emulated.c	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/libstuff/emulated.c	2009-03-18 13:55:56.233304000 -0400
@@ -0,0 +1,152 @@
+#include <mach/mach.h>
+#include <mach/mach_error.h>
+#include <mach/machine.h>
+#include <mach-o/dyld.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <errno.h>
+
+
+
+char            *mach_error_string(mach_error_t error_value)
+{
+  return "Unknown mach error";
+}
+
+mach_port_t mach_host_self(void)
+{
+  return 0;
+}
+
+kern_return_t host_info
+(
+ host_t host,
+ host_flavor_t flavor,
+ host_info_t host_info_out,
+ mach_msg_type_number_t *host_info_outCnt
+ )
+{
+  if(flavor == HOST_BASIC_INFO) {
+    host_basic_info_t      basic_info;
+
+    basic_info = (host_basic_info_t) host_info_out;
+    memset(basic_info, 0x00, sizeof(*basic_info));
+    basic_info->cpu_type = EMULATED_HOST_CPU_TYPE;
+    basic_info->cpu_subtype = EMULATED_HOST_CPU_SUBTYPE;
+  }
+
+  return 0;
+}
+
+mach_port_t     mach_task_self_ = 0;
+
+kern_return_t mach_port_deallocate
+(
+ ipc_space_t task,
+ mach_port_name_t name
+ )
+{
+  return 0;
+}
+
+kern_return_t vm_allocate
+(
+ vm_map_t target_task,
+ vm_address_t *address,
+ vm_size_t size,
+        int flags
+ )
+{
+
+  vm_address_t addr = 0;
+
+  addr = (vm_address_t)calloc(size, sizeof(char));
+  if(addr == 0)
+    return 1;
+
+  *address = addr;
+
+  return 0;
+}
+
+kern_return_t vm_deallocate
+(
+ vm_map_t target_task,
+ vm_address_t address,
+        vm_size_t size
+ )
+{
+  // Leak for now.  This is bad, but the tools that use this won't be
+  // long-lived.
+  // TODO(mark): Fix.  The problem is that vm_allocate/vm_deallocate have
+  // different semantics than malloc/free.  vm_deallocate frees things
+  // on a page-by-page basis where the pages may be a subset or a superset
+  // of a region obtained by any single vm_allocate call, where free frees
+  // entire blocks obtained from malloc.
+  // free((void *)address);
+
+  return 0;
+}
+
+kern_return_t vm_msync
+(
+ vm_map_t target_task,
+ vm_address_t address,
+ vm_size_t size,
+        vm_sync_t sync_flags
+ )
+{
+  // TODO(mark): Call msync?
+
+  return 0;
+}
+
+kern_return_t map_fd(
+                     int fd,
+                     vm_offset_t offset,
+                     vm_offset_t *va,
+                     boolean_t findspace,
+                     vm_size_t size)
+{
+
+  void *addr = NULL;
+
+  addr = mmap(0, size, PROT_READ|PROT_WRITE,
+	      MAP_PRIVATE|MAP_FILE, fd, offset);
+
+  if(addr == (void *)-1) {
+    return 1;
+  }
+
+  *va = (vm_offset_t)addr;
+
+  return 0;
+}
+
+#ifndef HAVE_QSORT_R
+void *_qsort_thunk = NULL;
+int (*_qsort_saved_func)(void *, const void *, const void *) = NULL;
+
+static int _qsort_comparator(const void *a, const void *b);
+
+static int _qsort_comparator(const void *a, const void *b)
+{
+  return _qsort_saved_func(_qsort_thunk, a, b);
+}
+
+void
+qsort_r(void *base, size_t nmemb, size_t size, void *thunk,
+	int (*compar)(void *, const void *, const void *))
+{
+  _qsort_thunk = thunk;
+  _qsort_saved_func = compar;
+
+  qsort(base, nmemb, size, _qsort_comparator);
+}
+
+#endif
+
+vm_size_t       vm_page_size = 4096; // hardcoded to match expectations of darwin
diff -U8 -N -r cctools-698.1.orig/libstuff/ofile.c cctools-698.1/libstuff/ofile.c
--- cctools-698.1.orig/libstuff/ofile.c	2008-04-21 13:07:38.000000000 -0400
+++ cctools-698.1/libstuff/ofile.c	2009-03-06 00:04:50.761709000 -0500
@@ -4044,17 +4044,17 @@
 			    }
 			    state += count * sizeof(long);
 			    break;
 			}
 			nflavor++;
 		    }
 		    break;
 		}
-#endif PPC_THREAD_STATE64_COUNT
+#endif /* PPC_THREAD_STATE64_COUNT */
 	    	if(cputype == CPU_TYPE_MC88000){
 		    m88k_thread_state_grf_t *cpu;
 		    m88k_thread_state_xrf_t *fpu;
 		    m88k_thread_state_user_t *user;
 		    m88110_thread_state_impl_t *spu;
 
 		    nflavor = 0;
 		    p = (char *)ut + ut->cmdsize;
diff -U8 -N -r cctools-698.1.orig/libstuff/swap_headers.c cctools-698.1/libstuff/swap_headers.c
--- cctools-698.1.orig/libstuff/swap_headers.c	2008-03-27 20:49:09.000000000 -0400
+++ cctools-698.1/libstuff/swap_headers.c	2009-03-05 21:40:23.286977000 -0500
@@ -1043,18 +1043,18 @@
 			  "load commands (path.offset field of LC_RPATH "
 			  "command %lu extends past the end of all load "
 			  "commands)", i);
 		    return(FALSE);
 		}
 		break;
 
 	    case LC_ENCRYPTION_INFO:
-		ld = (struct encryption_info_command *)lc;
-		if(ld->cmdsize != sizeof(struct encryption_info_command)){
+		ec = (struct encryption_info_command *)lc;
+		if(ec->cmdsize != sizeof(struct encryption_info_command)){
 		    error("in swap_object_headers(): malformed load commands "
 			  "(LC_ENCRYPTION_INFO command %lu has incorrect "
 			  "cmdsize", i);
 		    return(FALSE);
 		}
 		break;
 
 	    default:
diff -U8 -N -r cctools-698.1.orig/misc/Makefile.linux cctools-698.1/misc/Makefile.linux
--- cctools-698.1.orig/misc/Makefile.linux	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/misc/Makefile.linux	2009-03-06 11:20:32.714798000 -0500
@@ -0,0 +1,104 @@
+CFILES_codesign_allocate = codesign_allocate.c
+COBJS_codesign_allocate = $(CFILES_codesign_allocate:.c=.o)
+
+CFILES_install_name_tool = install_name_tool.c
+COBJS_install_name_tool = $(CFILES_install_name_tool:.c=.o)
+
+CFILES_libtool = libtool.c
+COBJS_libtool = $(CFILES_libtool:.c=.o)
+
+CFILES_lipo = lipo.c
+COBJS_lipo = $(CFILES_lipo:.c=.o)
+
+CFILES_nm = nm.c
+COBJS_nm = $(CFILES_nm:.c=.o)
+
+CFILES_nmedit = strip.c
+COBJS_nmedit = nmedit.o
+
+CFILES_pagestuff = pagestuff.c
+COBJS_pagestuff = $(CFILES_pagestuff:.c=.o)
+
+CFILES_segedit = segedit.c
+COBJS_segedit = $(CFILES_segedit:.c=.o)
+
+CFILES_size = size.c
+COBJS_size = $(CFILES_size:.c=.o)
+
+CFILES_strings = strings.c
+COBJS_strings = $(CFILES_strings:.c=.o)
+
+CFILES_strip = strip.c
+COBJS_strip = $(CFILES_strip:.c=.o)
+
+XCFLAGS = -fno-builtin-round -fno-builtin-trunc -D__LITTLE_ENDIAN__ -D__private_extern__='__attribute__((visibility("hidden")))' -I../include -I../../usr_include
+
+all: codesign_allocate \
+     install_name_tool \
+     libtool \
+     lipo \
+     nm \
+     nmedit \
+     pagestuff \
+     ranlib \
+     segedit \
+     size \
+     strings \
+     strip
+
+codesign_allocate: $(COBJS_codesign_allocate)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+install_name_tool: $(COBJS_install_name_tool)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+libtool: $(COBJS_libtool)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+lipo: $(COBJS_lipo)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+nm: $(COBJS_nm)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+nmedit: $(COBJS_nmedit)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+pagestuff: $(COBJS_pagestuff)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+ranlib: nmedit
+	ln -s $< $@
+
+segedit: $(COBJS_segedit)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+size: $(COBJS_size)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+strings: $(COBJS_strings)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+strip: $(COBJS_strip)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+.c.o:
+	$(CC) $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+nmedit.o: strip.c
+	$(CC) $(CFLAGS) $(XCFLAGS) -DNMEDIT -c -o $@ $<
+
+clean:
+	-rm -rf \
+	  codesign_allocate $(COBJS_codesign_allocate) \
+	  install_name_tool $(COBJS_install_name_tool) \
+	  libtool $(COBJS_libtool) \
+	  lipo $(COBJS_lipo) \
+	  nm $(COBJS_nm) \
+	  nmedit $(COBJS_nmedit) \
+	  pagestuff $(COBJS_pagestuff) \
+	  ranlib \
+	  segedit $(COBJS_segedit) \
+	  size $(COBJS_size) \
+	  strings $(COBJS_strings) \
+	  strip $(COBJS_strip)
diff -U8 -N -r cctools-698.1.orig/misc/libtool.c cctools-698.1/misc/libtool.c
--- cctools-698.1.orig/misc/libtool.c	2008-07-09 20:51:58.000000000 -0400
+++ cctools-698.1/misc/libtool.c	2009-03-06 11:17:52.383374000 -0500
@@ -46,22 +46,19 @@
 #include "stuff/allocate.h"
 #include "stuff/execute.h"
 #include "stuff/version_number.h"
 #include "stuff/unix_standard_mode.h"
 #ifdef LTO_SUPPORT
 #include "stuff/lto.h"
 #endif /* LTO_SUPPORT */
 
-#include "make.h"
 #include <mach/mach_init.h>
 #if defined(__OPENSTEP__) || defined(__GONZO_BUNSEN_BEAKER__)
 #include <servers/netname.h>
-#else
-#include <servers/bootstrap.h>
 #endif
 
 /* used by error routines as the name of the program */
 char *progname = NULL;
 
 /* the bytesex of the host this program is running on */
 static enum byte_sex host_byte_sex = UNKNOWN_BYTE_SEX;
 
@@ -2816,16 +2813,17 @@
 unsigned long v,
 unsigned long r)
 {
 	if(((long)v) < 0)
 	    return(0);
 	return(v & ~(r - 1));
 }
 
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 /*
  * tellProjectBuilder() is called to cause the doing messages to be sent to
  * ProjectBuilder.  The string pointed to by message and arch_name together
  * must not be more that 1024 characters.
  */
 static
 void
 tellProjectBuilder(
@@ -2864,16 +2862,17 @@
 	make_alert(ProjectBuilder_port,
 	    -1,
 	    NULL, 0, /* functionName, not used by ProjectBuilder */
 	    fileName, strlen(fileName)+1 > 1024 ? 1024 : strlen(fileName)+1,
 	    NULL, 0,
 	    0,
 	    message_buf, strlen(message_buf) + 1);
 }
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 
 /*
  * create_dynamic_shared_library() creates a dynamic shared library from the
  * data structure pointed to by archs into the specified output file.  Only
  * when more than one architecture is in archs will a fat file be created.
  */
 static
 void
@@ -2987,38 +2986,44 @@
 			add_execute_list(cmd_flags.filelist[j]);
 			filelist = cmd_flags.filelist[j];
 		    }
 		}
 	    }
 	    if(narchs <= 1){
 		add_execute_list("-o");
 		add_execute_list(cmd_flags.output);
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 		tellProjectBuilder("Linking %s", "", cmd_flags.output);
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 	    }
 	    else{
 		add_execute_list("-o");
 		add_execute_list(makestr(cmd_flags.output, ".libtool.",
 					 archs[i].arch_flag.name, NULL));
 		if(cmd_flags.final_output_specified == FALSE){
 		    add_execute_list("-final_output");
 		    add_execute_list(cmd_flags.output);
 		}
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 		tellProjectBuilder("Linking %s for ", archs[i].arch_flag.name,
 				   cmd_flags.output);
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 	    }
 	    if(execute_list(cmd_flags.verbose) == 0)
 		fatal("internal link edit command failed");
 	}
 	/*
 	 * If there is more than one architecture then run lipo to put them
 	 * in a fat file.
 	 */
 	if(narchs > 1){
+#ifdef OLD_PROJECTBUILDER_INTERFACE
 	    tellProjectBuilder("Combining into %s", "", cmd_flags.output);
+#endif /* OLD_PROJECTBUILDER_INTERFACE */
 	    reset_execute_list();
 	    add_execute_list("lipo");
 	    add_execute_list("-create");
 	    add_execute_list("-output");
 	    add_execute_list(cmd_flags.output);
 	    for(i = 0; i < narchs; i++){
 		add_execute_list(makestr(cmd_flags.output, ".libtool.",
 					 archs[i].arch_flag.name, NULL));
diff -U8 -N -r cctools-698.1.orig/misc/strip.c cctools-698.1/misc/strip.c
--- cctools-698.1.orig/misc/strip.c	2008-04-01 14:35:49.000000000 -0400
+++ cctools-698.1/misc/strip.c	2009-03-06 00:18:40.422920000 -0500
@@ -678,17 +678,17 @@
 		    p = rindex(input_file, '/');
 		    rename_file = makestr(p + 1, NULL);
 		}
 		/*
 		 * Create what might be a short enough name.
 		 */
 		free(output_file);
 		output_file = makestr("strip.XXXXXX", NULL);
-		output_file = mktemp(output_file);
+		close(mkstemp(output_file));
 	    }
 #endif /* NMEDIT */
 	    writeout(archs, narchs, output_file, stat_buf.st_mode & 0777,
 		     TRUE, FALSE, FALSE, NULL);
 	    if(rename_file != NULL){
 		if(rename(output_file, rename_file) == -1)
 		    system_error("can't move temporary file: %s to file: %s",
 				 output_file, rename_file);
@@ -3482,33 +3482,33 @@
 				  object->object_byte_sex);
 	}
 
 	/*
 	 * Create an input object file for the ld -r command from the bytes
 	 * of this arch's object file.
 	 */
 	input_file = makestr("/tmp/strip.XXXXXX", NULL);
-	input_file = mktemp(input_file);
+	close(mkstemp(input_file));
 
-	if((fd = open(input_file, O_WRONLY|O_CREAT, 0600)) < 0)
+	if((fd = open(input_file, O_WRONLY, 0600)) < 0)
 	    system_fatal("can't open temporary file: %s", input_file);
 
 	if(write(fd, object->object_addr, object->object_size) !=
 	        object->object_size)
 	    system_fatal("can't write temporary file: %s", input_file);
 
 	if(close(fd) == -1)
 	    system_fatal("can't close temporary file: %s", input_file);
 
 	/*
 	 * Create a temporary name for the output file of the ld -r
 	 */
 	output_file = makestr("/tmp/strip.XXXXXX", NULL);
-	output_file = mktemp(output_file);
+	close(mkstemp(output_file));
 
 	/*
 	 * Create the ld -r command line and execute it.
 	 */
 	reset_execute_list();
 	add_execute_list("ld");
 	add_execute_list("-keep_private_externs");
 	add_execute_list("-r");
diff -U8 -N -r cctools-698.1.orig/otool/Makefile.linux cctools-698.1/otool/Makefile.linux
--- cctools-698.1.orig/otool/Makefile.linux	1969-12-31 19:00:00.000000000 -0500
+++ cctools-698.1/otool/Makefile.linux	2009-03-06 12:58:35.171208000 -0500
@@ -0,0 +1,39 @@
+NULL =
+
+CFILES = \
+	arm_disasm.c \
+	coff_print.c \
+	hppa_disasm.c \
+	i386_disasm.c \
+	i860_disasm.c \
+	m68k_disasm.c \
+	m88k_disasm.c \
+	main.c \
+	notify.c \
+	ofile_print.c \
+	ppc_disasm.c \
+	print_objc2_32bit.c \
+	print_objc2_64bit.c \
+	sparc_disasm.c \
+	$(NULL)
+COBJS = $(CFILES:.c=.o)
+
+OBJCFILES = print_objc.c
+OBJCOBJS = $(OBJCFILES:.c=.o)
+
+XCFLAGS = -fno-builtin-round -D__LITTLE_ENDIAN__ -D__private_extern__='__attribute__((visibility("hidden")))' -I../include -I../../usr_include
+
+all: otool
+
+# Don't build print_objc.c into otool, it's wants the Apple Obj-C runtime.
+otool: $(COBJS)
+	$(CC) -o $@ $^ -L../libstuff -lstuff
+
+$(COBJS): %.o: %.c
+	$(CC) $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+$(OBJCOBJS): %.o: %.c
+	$(CC) -x objective-c $(CFLAGS) $(XCFLAGS) -c -o $@ $<
+
+clean:
+	-rm -rf otool $(COBJS) $(OBJCOBJS)
diff -U8 -N -r cctools-698.1.orig/otool/main.c cctools-698.1/otool/main.c
--- cctools-698.1.orig/otool/main.c	2008-03-31 20:16:28.000000000 -0400
+++ cctools-698.1/otool/main.c	2009-03-06 10:37:31.227300000 -0500
@@ -1133,42 +1133,54 @@
 
 	if(segname != NULL && sectname != NULL &&
 	   (sect_flags & S_ATTR_PURE_INSTRUCTIONS) !=
 		S_ATTR_PURE_INSTRUCTIONS &&
 	   (sect_flags & S_ATTR_SOME_INSTRUCTIONS) !=
 		S_ATTR_SOME_INSTRUCTIONS){
 	    if(strcmp(segname, SEG_OBJC) == 0 &&
 	       strcmp(sectname, "__protocol") == 0 && vflag == TRUE){
+#ifdef HAVE_OBJC_OBJC_RUNTIME_H
 		print_objc_protocol_section(ofile->load_commands, mh_ncmds,
 		   mh_sizeofcmds, ofile->object_byte_sex, ofile->object_addr,
 		   ofile->object_size, vflag);
+#else
+		printf("Objective-C not supported\n");
+#endif
 	    }
 	    else if(strcmp(segname, SEG_OBJC) == 0 &&
 	            (strcmp(sectname, "__string_object") == 0 ||
 	             strcmp(sectname, "__cstring_object") == 0) &&
 		    vflag == TRUE){
 		if(mh_cputype & CPU_ARCH_ABI64)
 		    print_objc_string_object_section_64(sectname,
 			ofile->load_commands, mh_ncmds, mh_sizeofcmds,
 			ofile->object_byte_sex, ofile->object_addr,
 			ofile->object_size, mh_cputype, symbols64, nsymbols,
 			strings, strings_size, sorted_symbols, nsorted_symbols,
 			vflag);
 		else
+#ifdef HAVE_OBJC_OBJC_RUNTIME_H
 		    print_objc_string_object_section(sectname,
 			ofile->load_commands, mh_ncmds, mh_sizeofcmds,
 			ofile->object_byte_sex, ofile->object_addr,
 			ofile->object_size, vflag);
+#else
+		    printf("Objective-C not supported.\n");
+#endif
 	    }
 	    else if(strcmp(segname, SEG_OBJC) == 0 &&
 	       strcmp(sectname, "__runtime_setup") == 0 && vflag == TRUE){
+#ifdef HAVE_OBJC_OBJC_RUNTIME_H
 		print_objc_runtime_setup_section(ofile->load_commands, mh_ncmds,
 		   mh_sizeofcmds, ofile->object_byte_sex, ofile->object_addr,
 		   ofile->object_size, vflag);
+#else
+		printf("Objective-C not supported\n");
+#endif
 	    }
 #ifdef EFI_SUPPORT
 	    else if(strcmp(segname, "__RELOC") == 0 &&
 	       strcmp(sectname, "__reloc") == 0 && vflag == TRUE){
 		print_coff_reloc_section(ofile->load_commands, mh_ncmds,
 		   mh_sizeofcmds, mh_filetype, ofile->object_byte_sex,
 		   ofile->object_addr, ofile->object_size, vflag);
 	    }
@@ -1335,20 +1347,24 @@
 		print_objc2_32bit(mh_cputype, ofile->load_commands, mh_ncmds,
 			    mh_sizeofcmds, ofile->object_byte_sex,
 			    ofile->object_addr, ofile->object_size, symbols,
 			    nsymbols, strings, strings_size, sorted_symbols,
 			    nsorted_symbols, ext_relocs, next_relocs,
 			    loc_relocs, nloc_relocs, vflag);
 	    }
 	    else{
+#ifdef HAVE_OBJC_OBJC_RUNTIME_H
 		 print_objc_segment(ofile->load_commands,mh_ncmds,mh_sizeofcmds,
 				    ofile->object_byte_sex, ofile->object_addr,
 				    ofile->object_size, sorted_symbols,
 				    nsorted_symbols, vflag);
+#else
+		 printf("Objective-C not supported\n");
+#endif
 	    }
 	}
 
 	if(load_commands != NULL)
 	    free(load_commands);
 	if(allocated_symbols != NULL)
 	    free(allocated_symbols);
 	if(sorted_symbols != NULL)
diff -U8 -N -r cctools-698.1.orig/otool/notify.c cctools-698.1/otool/notify.c
--- cctools-698.1.orig/otool/notify.c	2006-07-25 19:04:46.000000000 -0400
+++ cctools-698.1/otool/notify.c	2009-03-06 10:03:57.957974000 -0500
@@ -16,17 +16,17 @@
  * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
  * Please see the License for the specific language governing rights and
  * limitations under the License.
  * 
  * @APPLE_LICENSE_HEADER_END@
  */
 #ifndef __DYNAMIC__
-#include <notify.h>
+#include "notify.h"
 
 uint32_t notify_post(const char *name)
 {
 	return 0;
 }
 
 uint32_t notify_register_check(const char *name, int *out_token)
 {
diff -U8 -N -r cctools-698.1.orig/otool/notify.h cctools-698.1/otool/notify.h
--- cctools-698.1.orig/otool/notify.h	2003-08-14 17:36:37.000000000 -0400
+++ cctools-698.1/otool/notify.h	2009-03-06 10:33:03.941926000 -0500
@@ -205,9 +205,9 @@
  * Input parameter
  *     token - notification token
  * Returns status.
  */
 uint32_t notify_cancel(int token);
 
 __END_DECLS
 
-#endif __NOTIFICATION_H__
+#endif /* __NOTIFICATION_H__ */
