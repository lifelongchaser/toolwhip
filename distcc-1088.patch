diff -U8 -r -N distcc-1088.orig/distcc_dist/Makefile.in distcc-1088/distcc_dist/Makefile.in
--- distcc-1088.orig/distcc_dist/Makefile.in	2005-11-09 14:52:36.000000000 -0500
+++ distcc-1088/distcc_dist/Makefile.in	2009-03-10 16:59:09.184394000 -0400
@@ -51,17 +51,17 @@
 # contain variable expansions written in Make syntax.  Ew.
 DIR_DEFS = -DSYSCONFDIR="\"${sysconfdir}\"" -DPKGDATADIR="\"${pkgdatadir}\""
 
 # arguments to pkgconfig
 GNOME_PACKAGES = @GNOME_PACKAGES@
 GNOME_CFLAGS = @GNOME_CFLAGS@
 GNOME_LIBS = @GNOME_LIBS@
 
-LIBS = @LIBS@ /usr/lib/libcrypto.dylib
+LIBS = @LIBS@
 
 DESTDIR =
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@ 
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/dopt.c distcc-1088/distcc_dist/src/dopt.c
--- distcc-1088.orig/distcc_dist/src/dopt.c	2005-11-10 18:27:58.000000000 -0500
+++ distcc-1088/distcc_dist/src/dopt.c	2009-03-10 18:23:01.329212000 -0400
@@ -100,16 +100,18 @@
 
 /* Enumeration values for options that don't have single-letter name.  These
  * must be numerically above all the ascii letters. */
 enum {
     opt_log_to_file = 300,
     opt_log_level
 };
 
+const char* opt_system_version = NULL;
+
 
 const struct poptOption options[] = {
     { "allow", 'a',      POPT_ARG_STRING, 0, 'a', 0, 0 },
     { "jobs", 'j',       POPT_ARG_INT, &arg_max_jobs, 'j', 0, 0 },
     { "daemon", 0,       POPT_ARG_NONE, &opt_daemon_mode, 0, 0, 0 },
     { "help", 0,         POPT_ARG_NONE, 0, '?', 0, 0 },
     { "inetd", 0,        POPT_ARG_NONE, &opt_inetd_mode, 0, 0, 0 },
     { "lifetime", 0,     POPT_ARG_INT, &opt_lifetime, 0, 0, 0 },
@@ -127,16 +129,17 @@
     { "verbose", 0,      POPT_ARG_NONE, 0, 'v', 0, 0 },
     { "version", 0,      POPT_ARG_NONE, 0, 'V', 0, 0 },
     { "wizard", 'W',     POPT_ARG_NONE, 0, 'W', 0, 0 },
     { "host-info", 'I',     POPT_ARG_NONE, 0, 'I', 0, 0 },
     { "max-cache-age", 0, POPT_ARG_INT,  &pullfile_cache_max_age,  0, 0, 0 },
     { "max-cache-size", 0, POPT_ARG_INT,  &pullfile_max_cache_size,  0, 0, 0 },
     { "min-disk-free", 0, POPT_ARG_INT,  &pullfile_min_free_space,  0, 0, 0 },
     { "priority", 0,     POPT_ARG_INT,  &build_machine_priority,  0, 0, 0 },
+    { "system-version", 0, POPT_ARG_STRING, &opt_system_version, 0, 0, 0},
     { 0, 0, 0, 0, 0, 0, 0 }
 };
 
 
 static void distccd_show_usage(void)
 {
     dcc_show_version("distccd");
     printf (
@@ -148,16 +151,18 @@
 "    --version                  show version and exit\n"
 "    -P, --pid-file FILE        save daemon process id to file\n"
 "    -N, --nice LEVEL           lower priority, 20=most nice\n"
 "    --user USER                if run by root, change to this persona\n"
 "    --jobs, -j LIMIT           maximum tasks at any time\n"
 "    --max-cache-age            maximum time cached file are kept (hours)\n"
 "    --max-cache-size           maximum disk use for cached files (Mb)\n"
 "    --min-disk-free            minimum free space to preserve on cache filesystem (Mb)\n"
+"    --system-version=STRING    lie and pretend to be this type of system\n"
+"                               example: \"10.5.6 (9G55, i386)\"\n"
 "  Networking:\n"
 "    -p, --port PORT            TCP port to listen on\n"
 "    --listen ADDRESS           IP address to listen on\n"
 "    -a, --allow IP[/BITS]      client address access control\n"
 "  Debug and trace:\n"
 "    --log-level=LEVEL          set detail level for log file\n"
 "      levels: critical, error, warning, notice, info, debug\n"
 "    --verbose                  set log level to \"debug\"\n"
@@ -267,15 +272,22 @@
             rs_log(RS_LOG_NONAME|RS_LOG_ERR|RS_LOG_NO_PID, "%s: %s",
                    poptBadOption(po, POPT_BADOPTION_NOALIAS),
                    poptStrerror(po_err));
             exitcode = EXIT_BAD_ARGUMENTS;
             goto out_exit;
         }
     }
 
+    if (!opt_system_version) {
+        rs_log(RS_LOG_NONAME|RS_LOG_ERR|RS_LOG_NO_PID,
+               "must supply --system-version");
+        exitcode = EXIT_BAD_ARGUMENTS;
+        goto out_exit;
+    }
+
     poptFreeContext(po);
     return 0;
 
     out_exit:
     poptFreeContext(po);
     exit(exitcode);
 }
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/dopt.h distcc-1088/distcc_dist/src/dopt.h
--- distcc-1088.orig/distcc_dist/src/dopt.h	2005-11-10 18:27:58.000000000 -0500
+++ distcc-1088/distcc_dist/src/dopt.h	2009-03-10 18:11:42.952824000 -0400
@@ -34,8 +34,9 @@
 extern int opt_daemon_mode, opt_inetd_mode;
 extern const char *arg_log_file;
 extern int opt_no_fifo;
 extern int opt_log_stderr;
 extern int opt_lifetime;
 extern char *opt_listen_addr;
 extern int opt_niceness;
 extern int build_machine_priority;
+extern const char* opt_system_version;
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/indirect_client.c distcc-1088/distcc_dist/src/indirect_client.c
--- distcc-1088.orig/distcc_dist/src/indirect_client.c	2005-10-27 20:15:38.000000000 -0400
+++ distcc-1088/distcc_dist/src/indirect_client.c	2009-03-10 13:48:37.015540000 -0400
@@ -30,17 +30,17 @@
 
 #include <errno.h>
 #include <fcntl.h>
 #include <inttypes.h>
 #include <openssl/md5.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/dirent.h>
+#include <dirent.h>
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
 #include "distcc.h"
 #include "bulk.h"
 #include "indirect_client.h"
 #include "indirect_util.h"
@@ -93,35 +93,35 @@
         
     /* validate the size and mod time of the file against the local filesystem. */
     if (result == 0) {
         if (stat(path, &st_pullfile) != 0) {
             result = -1;
             pull_response = indirection_pull_response_file_missing;
             rs_log_warning("Unable to send pull file: %s - %s", path, strerror(errno));
         } else {
-            if (file_stat_info_flag == indirection_file_stat_info_present && st_pullfile.st_size == file_size && st_pullfile.st_mtimespec.tv_sec == mod_time.tv_sec && st_pullfile.st_mtimespec.tv_nsec == mod_time.tv_nsec) {
+            if (file_stat_info_flag == indirection_file_stat_info_present && st_pullfile.st_size == file_size && st_pullfile.st_mtime == mod_time.tv_sec && st_pullfile.st_mtim.tv_nsec == mod_time.tv_nsec) {
                 pull_response = indirection_pull_response_file_ok;
                 rs_log_info("using cached pull file");
             } else {
                 if (file_stat_info_flag == indirection_file_stat_info_present) {
                     rs_log_info("pull file changed, sending");
-                    rs_log_info("my size = %d, my seconds = %d, my nsec = %d\nhis size = %d, his seconds = %d, his nsec = %d", (int)st_pullfile.st_size, st_pullfile.st_mtimespec.tv_sec, st_pullfile.st_mtimespec.tv_nsec, (int)file_size, mod_time.tv_sec, mod_time.tv_nsec);
+                    rs_log_info("my size = %d, my seconds = %d, my nsec = %d\nhis size = %d, his seconds = %d, his nsec = %d", (int)st_pullfile.st_size, st_pullfile.st_mtime, st_pullfile.st_mtim.tv_nsec, (int)file_size, mod_time.tv_sec, mod_time.tv_nsec);
                 } else {
                     rs_log_info("pull file missing, sending");
                 }
                 pull_response = indirection_pull_response_file_download;
             }
         }
         if ((result = dcc_x_token_int(ifd, indirection_pull_response_token, pull_response)) != 0) {
             rs_log_error("unable to send pull response code");
         } else {
             if (pull_response == indirection_pull_response_file_download) {
                 if (dcc_x_file(ifd, path, indirection_pull_file, DCC_COMPRESS_LZO1X, &send_size) ||
-                    dcc_writex(ifd, &st_pullfile.st_mtimespec, sizeof(st_pullfile.st_mtimespec))) {
+                    dcc_writex(ifd, &st_pullfile.st_mtim, sizeof(st_pullfile.st_mtim))) {
                     rs_log_error("failure sending pull file");
                 }
             }
         }
     } else {
         // we failed somewhere reading the request
     }
     return result;
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/indirect_server.c distcc-1088/distcc_dist/src/indirect_server.c
--- distcc-1088.orig/distcc_dist/src/indirect_server.c	2006-04-04 19:41:48.000000000 -0400
+++ distcc-1088/distcc_dist/src/indirect_server.c	2009-03-10 13:45:56.534064000 -0400
@@ -29,20 +29,22 @@
 #include <fcntl.h>
 #include <netinet/in.h>
 #include <pthread.h>
 #include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
-#include <sys/dirent.h>
+#include <dirent.h>
+#include <sys/file.h>
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/statfs.h>
 #include <sys/types.h>
 #include <sys/mount.h>
 #include <fts.h>
 #include "distcc.h"
 #include "bulk.h"
 #include "config.h"
 #include "exitcode.h"
 #include "exec.h"
@@ -134,17 +136,21 @@
 static int lock_pullfile()
 {
     static char *pull_lock = NULL;
     if (pull_lock == NULL) {
         if (dcc_make_tmpfile_path(&pull_lock, 1, "pull_lockfile", NULL)) {
             return -1;
         }
     }
-    return open(pull_lock, O_WRONLY|O_CREAT|O_EXLOCK, 0777);
+    int fd = open(pull_lock, O_WRONLY|O_CREAT, 0777);
+    if (fd != -1) {
+        flock(fd, LOCK_EX);
+    }
+    return fd;
 }
 
 typedef struct _CachedPullfile {
     char *path;
     time_t accessTime;
     off_t size; // size in kb
     struct _CachedPullfile *next;
 } CachedPullfile;
@@ -176,20 +182,20 @@
         int entry_index;
         do {
             file = fts_read(fts_handle);
             if ((file != NULL) && (file->fts_info == FTS_F)) {
                 CachedPullfile *newNode = (CachedPullfile *)malloc(sizeof(CachedPullfile));
                 newNode->path = (char *)malloc(file->fts_pathlen + 1);
                 bcopy(file->fts_path, newNode->path, file->fts_pathlen);
                 newNode->path[file->fts_pathlen] = 0;
-                newNode->accessTime = file->fts_statp->st_mtimespec.tv_sec;
+                newNode->accessTime = file->fts_statp->st_mtim.tv_sec;
                 newNode->size = (file->fts_statp->st_size + 1023) / 1024;
                 // Figure out what cache_lists bucket to put the file into.
-                age = current_time - file->fts_statp->st_atimespec.tv_sec;
+                age = current_time - file->fts_statp->st_atim.tv_sec;
                 if (age > 60 * 60) {
                     // it's at least one hour old so calculate time in hours starting with bucket 6
                     entry_index = 5 + age / (60 * 60);
                 } else {
                     // it's less than one hour old so calculate time in 10 minute intervals starting with bucket 0
                     entry_index = age / (10 * 60);
                 }
                 if (entry_index >= cache_lists_size)
@@ -423,18 +429,19 @@
         if (dcc_x_token_int(indirect->out_fd, indirection_request_token, indirection_request_pull) ||
             dcc_x_token_int(indirect->out_fd, indirection_path_length_token, pullfile_len) ||
             dcc_writex(indirect->out_fd, pullfile, pullfile_len)) {
             result = -1;
         } else {
             /* if we have a file cached locally send the stat info, otherwise send the flag that we don't have a file */
             if (has_local_file) {
                 if (result == 0) result = dcc_x_token_int(indirect->out_fd, indirection_file_stat_token, indirection_file_stat_info_present);
-                if (result == 0) result = dcc_writex(indirect->out_fd, &st_pch.st_size, sizeof(st_pch.st_size));
-                if (result == 0) result = dcc_writex(indirect->out_fd, &st_pch.st_mtimespec, sizeof(st_pch.st_mtimespec));
+                long long st_size_64 = st_pch.st_size;
+                if (result == 0) result = dcc_writex(indirect->out_fd, &st_size_64, sizeof(st_size_64));
+                if (result == 0) result = dcc_writex(indirect->out_fd, &st_pch.st_mtim, sizeof(st_pch.st_mtim));
             } else {
                 if (dcc_x_token_int(indirect->out_fd, indirection_file_stat_token, indirection_no_file_stat_info))
                     result = -1;
             }
         }
     }
     
     /* read the client's response */
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/ncpus.c distcc-1088/distcc_dist/src/ncpus.c
--- distcc-1088.orig/distcc_dist/src/ncpus.c	2005-07-28 21:57:24.000000000 -0400
+++ distcc-1088/distcc_dist/src/ncpus.c	2009-03-10 13:45:56.539053000 -0400
@@ -151,16 +151,39 @@
 
 /*
   http://www.opengroup.org/onlinepubs/007904975/functions/sysconf.html
   http://docs.sun.com/?p=/doc/816-0213/6m6ne38dd&a=view
   http://www.tru64unix.compaq.com/docs/base_doc/DOCUMENTATION/V40G_HTML/MAN/MAN3/0629____.HTM
   http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&db=man&fname=/usr/share/catman/p_man/cat3c/sysconf.z
 */
 
+int dcc_cpuspeed(unsigned long long *speed)
+{
+  FILE* f = fopen("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq", "r");
+  if (!f) {
+    rs_log_error("open cpuinfo_max_freq failed: %s", strerror(errno));
+    *speed = 1;
+    return EXIT_DISTCC_FAILED;
+  }
+
+  long long khz;
+  int fscanf_rv = fscanf(f, "%lld", &khz);
+  fclose(f);
+
+  if (fscanf_rv != 1 || khz <= 0) {
+    rs_log_error("cpuinfo_max_freq makes no sense");
+    *speed = 1;
+    return EXIT_DISTCC_FAILED;
+  }
+
+  *speed = khz * 1000;
+  return 0;
+}
+
 int dcc_ncpus(int *ncpus)
 {
 #if defined(_SC_NPROCESSORS_ONLN)
     /* Linux, Solaris, Tru64, UnixWare 7, and Open UNIX 8  */
     *ncpus = sysconf(_SC_NPROCESSORS_ONLN);
 #elif defined(_SC_NPROC_ONLN)
     /* IRIX */
     *ncpus = sysconf(_SC_NPROC_ONLN);
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/util.c distcc-1088/distcc_dist/src/util.c
--- distcc-1088.orig/distcc_dist/src/util.c	2005-07-08 19:30:13.000000000 -0400
+++ distcc-1088/distcc_dist/src/util.c	2009-03-10 16:58:40.282422000 -0400
@@ -398,8 +398,42 @@
 	if (bufsize <= 0) return 0;
 	if (len >= bufsize) len = bufsize-1;
 	memcpy(d, s, len);
 	d[len] = 0;
 	return ret;
 }
 #endif
 
+
+#ifndef HAVE_STRLCAT
+/* Libc-498.1.1/string/strlcat-fbsd.c */
+size_t
+strlcat(dst, src, siz)
+	char *dst;
+	const char *src;
+	size_t siz;
+{
+	char *d = dst;
+	const char *s = src;
+	size_t n = siz;
+	size_t dlen;
+
+	/* Find the end of dst and adjust bytes left but don't go past end */
+	while (n-- != 0 && *d != '\0')
+		d++;
+	dlen = d - dst;
+	n = siz - dlen;
+
+	if (n == 0)
+		return(dlen + strlen(s));
+	while (*s != '\0') {
+		if (n != 1) {
+			*d++ = *s;
+			n--;
+		}
+		s++;
+	}
+	*d = '\0';
+
+	return(dlen + (s - src));	/* count does not include NUL */
+}
+#endif
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/util.h distcc-1088/distcc_dist/src/util.h
--- distcc-1088.orig/distcc_dist/src/util.h	2005-07-08 19:30:13.000000000 -0400
+++ distcc-1088/distcc_dist/src/util.h	2009-03-10 18:15:58.328737000 -0400
@@ -22,17 +22,17 @@
 
 #include <setjmp.h>
 
 /* util.c */
 int argv_contains(char **argv, const char *s);
 int dcc_redirect_fd(int, const char *fname, int);
 int str_startswith(const char *head, const char *worm);
 char *dcc_gethostname(void);
-void dcc_exit(int exitcode) NORETURN;
+void dcc_exit(int exitcode);
 int dcc_getenv_bool(const char *name, int def_value);
 int set_cloexec_flag (int desc, int value);
 int dcc_ignore_sigpipe(int val);
 int dcc_remove_if_exists(const char *fname);
 int dcc_trim_path(const char *compiler_name);
 int dcc_set_path(const char *newpath);
 char *dcc_abspath(const char *path, int path_len);
 
@@ -41,8 +41,11 @@
 
 
 int dcc_dup_part(const char **psrc, char **pdst, const char *sep);
 
 #ifndef HAVE_STRLCPY
 size_t strlcpy(char *d, const char *s, size_t bufsize);
 #endif
 
+#ifndef HAVE_STRLCAT
+size_t strlcat(char *d, const char *s, size_t bufsize);
+#endif
diff -U8 -r -N distcc-1088.orig/distcc_dist/src/versinfo.c distcc-1088/distcc_dist/src/versinfo.c
--- distcc-1088.orig/distcc_dist/src/versinfo.c	2008-04-29 18:00:17.000000000 -0400
+++ distcc-1088/distcc_dist/src/versinfo.c	2009-03-10 18:36:43.318127000 -0400
@@ -4,18 +4,20 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/sysctl.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include <mach-o/arch.h>
+#include <sys/param.h>
+#include "dopt.h"
 #include "trace.h"
+#include "util.h"
 #include "versinfo.h"
 
 // Path to xcode-select(1) to use to find the current developer directory path
 #define XCODE_SELECT_PATH "/usr/bin/xcode-select"
 // Environment variable controlling whether to use xcode-select(1) to find compilers
 #define XCODE_SELECT_ENV_SWITCH "USE_XCODE_SELECT_PATH"
 
 typedef struct _CompilerInfo {
@@ -63,17 +65,21 @@
 {
     static char exe_path[PATH_MAX];
     char buf[PATH_MAX];
     uint32_t bufsize = sizeof(buf);
     char *cp;
 
     if (*exe_path) return exe_path;
         
+#if 0
     if (_NSGetExecutablePath(buf, &bufsize) != 0) {
+#else
+    if (readlink("/proc/self/exe", buf, sizeof(buf)) == -1) {
+#endif
         rs_log_error("Cannot get executable path for compilers");
         return NULL;
     }
 
     cp = buf + strlen(buf);
 
     while (cp > buf && *--cp != '/') {} /* skip over progname */
 
@@ -105,17 +111,22 @@
 }
 
 /* Get the path to the usr directory in the xcode-select-indicated developer directory */
 static const char *dcc_get_xcodeselect_path()
 {
     char *returnPath = NULL;
     static char xcodeSelectUsrPath[PATH_MAX];
 
+#if 0
     char *developerPath = dcc_run_simple_command(XCODE_SELECT_PATH" --print-path");
+#else
+    char *developerPath = malloc(PATH_MAX);
+    strlcpy(developerPath, "/Developer", PATH_MAX);
+#endif
     if (NULL == developerPath) {
         rs_log_error(XCODE_SELECT_PATH" failed.");
     }
     else {
         char unresolvedPath[PATH_MAX];
         strlcpy(unresolvedPath, developerPath, sizeof(unresolvedPath));
         
         // Strip trailing newline
@@ -140,17 +151,17 @@
     return returnPath;
 }
 
 /* Get the path to the usr directory to use */
 static const char *dcc_get_usr_path()
 {
     const char *usr_path;
     
-    if (dcc_getenv_bool(XCODE_SELECT_ENV_SWITCH)) {
+    if (dcc_getenv_bool(XCODE_SELECT_ENV_SWITCH, NULL)) {
         usr_path = dcc_get_xcodeselect_path();
     }
     else {
         usr_path = dcc_get_executable_path();
     }
         
     return usr_path;
 }
@@ -312,17 +323,17 @@
 static char *_dcc_get_compiler_version(CompilerInfo *compiler)
 {
     char *result = NULL;
     struct stat sb;
     if (compiler) {
         const char *c_path = compiler->abs_path;
         if (stat(c_path, &sb) == 0 && compiler->versionInfo != NULL) {
             // we found the compiler, check that the timestamp is unchanged
-            if (memcmp(&sb.st_ctimespec, &compiler->modTime, sizeof(struct timespec)) != 0) {
+            if (memcmp(&sb.st_ctim, &compiler->modTime, sizeof(struct timespec)) != 0) {
                 // didn't match, so throw away version number
                 rs_log_warning("compiler version changed: %s", c_path);
                 //free(compiler->versionInfo); // leak; should be very uncommon
                 compiler->versionInfo = NULL;
             }
         }
         
         if (!compiler->versionInfo) {
@@ -338,17 +349,17 @@
                 char *version = strstr(versionOutput, "gcc version");
                 if (version) {
                     int newline = 0;
                     while (version[newline] != '\n' && version[newline] != 0)
                         newline++;
                     compiler->versionInfo = (char *)malloc(newline+1);
                     strncpy(compiler->versionInfo, version, newline);
                     compiler->versionInfo[newline]=0;
-                    compiler->modTime = sb.st_ctimespec;
+                    compiler->modTime = sb.st_ctim;
                 }
             }
         }
         result = compiler->versionInfo;
     }
     return result;
 }
 
@@ -410,16 +421,17 @@
     return result;
 }
 
 
 char *dcc_get_system_version(void)
 {
     static char *ret = NULL;
     if (ret == NULL) {
+#if 0
         char *sw_vers = dcc_run_simple_command("/usr/bin/sw_vers");
         if (sw_vers) {
             char *prodVers, *prodVersStr = "ProductVersion:";
             char *buildVers, *buildVersStr = "BuildVersion:";
             char *nl;
             char archbuf[32];
             
             prodVers = strstr(sw_vers, prodVersStr);
@@ -477,11 +489,14 @@
                 archName = "unknown";
             }
             
             // construct a string of the form 10.x.y (9A192, ppc)
             ret = malloc(strlen(prodVers) + strlen(buildVers) + strlen(archName) + strlen(" (, )") + 1);
             sprintf(ret, "%s (%s, %s)", prodVers, buildVers, archName);
             free(sw_vers);
         }
+#else
+        ret = strdup(opt_system_version);
+#endif
     }
     return ret;
 }
