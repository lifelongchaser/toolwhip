diff -U8 -r -N distcc-3.1.orig/include_server/compiler_defaults.py distcc-3.1/include_server/compiler_defaults.py
--- distcc-3.1.orig/include_server/compiler_defaults.py	2008-12-02 16:50:31.000000000 -0500
+++ distcc-3.1/include_server/compiler_defaults.py	2009-03-13 13:10:01.000000000 -0400
@@ -71,17 +71,17 @@
     if os.path.islink(prefix):
       return last_prefix, True
     if not os.path.isdir(prefix):
       return last_prefix, False
   return path, False
 
 
 def _MakeLinkFromMirrorToRealLocation(system_dir, client_root, system_links):
-  """Create a link under client root what will resolve to system dir on server.
+  """Create a link under client root that will resolve to system dir on server.
 
   See comments for CompilerDefaults class for rationale.
 
   Args:
     system_dir: a path such as /usr/include or
                 /usr/lib/gcc/i486-linux-gnu/4.0.3/include
     client_root: a path such as /dev/shm/tmpX.include_server-X-1
     system_links: a list of paths under client_root; each denotes a symlink
@@ -224,24 +224,43 @@
              + "command '%s' exited with status '%d'.\n Command output:\n%s") %
              (compiler, language, command, p.returncode, out))
 
   match_obj = re.search(
     r"%s\n(.*?)\n%s"  # don't ask
     % ("#include <...> search starts here:", "End of search list"),
     out,
     re.MULTILINE + re.DOTALL)
+
+  parse_error_msg = \
+           ( "Couldn't determine default system include directories\n"
+           + "for compiler '%s', language '%s':\n"
+           + "couldn't parse output of '%s'.\nReceived:\n%s") % \
+           (compiler, language, command, out)
+
   if match_obj == None:
-    raise NotCoveredError(
-             ( "Couldn't determine default system include directories\n"
-             + "for compiler '%s', language '%s':\n"
-             + "couldn't parse output of '%s'.\nReceived:\n%s") %
-             (compiler, language, command, out))
-  return [ canonical_lookup(directory)
-           for directory in match_obj.group(1).split() ]
+    raise NotCoveredError(parse_error_msg)
+
+  directories = []
+  for directory in match_obj.group(1).split('\n'):
+    if not directory.startswith(' '):
+      raise NotCoveredError(parse_error_msg)
+
+    directory = directory[1:]
+
+    # For our purposes, it doesn't matter whether the directory is a framework
+    # directory (-F) or an include directory (-I).  This only applies when
+    # using Apple GCC.
+    framework_string = ' (framework directory)'
+    if directory.endswith(framework_string):
+      directory = directory[:-len(framework_string)]
+
+    directories.append(canonical_lookup(directory))
+
+  return directories
 
 
 class CompilerDefaults(object):
   """Records and caches the default search dirs and creates symlink farm.
 
   This function works only for gcc, and only some versions at that,
   because we parse the output from gcc to determine the default search dirs.
 
diff -U8 -r -N distcc-3.1.orig/include_server/parse_command.py distcc-3.1/include_server/parse_command.py
--- distcc-3.1.orig/include_server/parse_command.py	2008-12-02 16:50:31.000000000 -0500
+++ distcc-3.1/include_server/parse_command.py	2009-03-13 13:37:47.000000000 -0400
@@ -50,24 +50,26 @@
     self.before_system_dirs = []
     self.after_system_dirs = []
 
     self.language = 'none'    # equivalent to commandline of '-x none'
     self.isysroot = None
     self.sysroot = None
     self.output_file = None
     self.iprefix = ""
+    self.arch = None
     self.Dopts = []
 
   def set_nostdinc(self): self.nostdinc = True
   def set_language(self, x): self.language = x
   def set_isysroot(self, x): self.isysroot = x
   def set_sysroot(self, x): self.sysroot = x
   def set_outputfile(self, x): self.output_file = x
   def set_iprefix(self, x): self.iprefix = x
+  def set_arch(self, x): self.arch = x
 
 def _SplitMacroArg(arg):
   """Split an arg as found in -Darg
 
   Argument:
     arg: argument
 
   Returns: [arg] if there is no '=' in arg, otherwise [symb, val], where symb is
@@ -91,26 +93,26 @@
 # and, more completely, from the gnu gcc info pages.
 # Each option takes as a value, the function to run on the opt's argument.
 # Below, ps is a ParseState object.
 # TODO(csilvers): check for arg[0] == '=' for iquote, isystem
 CPP_OPTIONS_MAYBE_TWO_WORDS = {
   '-MF':            lambda ps, arg: None,
   '-MT':            lambda ps, arg: None,
   '-MQ':            lambda ps, arg: None,
+  '-arch':          lambda ps, arg: ps.set_arch(arg),
   '-include':       lambda ps, arg: ps.include_files.append(arg),
   '-imacros':       lambda ps, arg: ps.include_files.append(arg),
   '-idirafter':     lambda ps, arg: ps.after_system_dirs.append(arg),
   '-iprefix':       lambda ps, arg: ps.set_iprefix(arg),
   '-iwithprefix':   lambda ps, arg: ps.after_system_dirs.append(
                                       os.path.join(ps.iprefix, arg)),
   '-iwithprefixbefore':  lambda ps, arg: ps.i_dirs.append(
                                            os.path.join(ps.iprefix, arg)),
-#  '-isysroot':      lambda ps, arg: ps.set_isysroot(arg),
-  '-isysroot':      lambda ps, arg: _RaiseNotImplemented('-isysroot'),
+  '-isysroot':      lambda ps, arg: ps.set_isysroot(arg),
   '-imultilib':     lambda ps, arg: _RaiseNotImplemented('-imultilib'),
   '-isystem':       lambda ps, arg: ps.before_system_dirs.append(arg),
   '-iquote':        lambda ps, arg: ps.quote_dirs.append(arg),
 #  '--sysroot=':     lambda ps, arg: ps.set_sysroot(arg),
   '--sysroot=':     lambda ps, arg: None,
 }
 CPP_OPTIONS_MAYBE_TWO_WORDS_FIRST_LETTERS = ('M', 'i', '-')
 # A "compile-time" check to make sure the first-letter list is up-to-date
diff -U8 -r -N distcc-3.1.orig/src/arg.c distcc-3.1/src/arg.c
--- distcc-3.1.orig/src/arg.c	2008-12-02 16:50:24.000000000 -0500
+++ distcc-3.1/src/arg.c	2009-03-18 19:51:11.000000000 -0400
@@ -139,16 +139,23 @@
     if ((ret = dcc_copy_argv(argv, ret_newargv, 2)) != 0)
         return ret;
     argv = *ret_newargv;
 
     /* FIXME: new copy of argv is leaked */
 
     dcc_trace_argv("scanning arguments", argv);
 
+#ifdef XCODE_INTEGRATION
+    /* Xcode invokes "distcc --host-info HOST" to gather info about HOST. */
+    if (!strcmp(argv[0], "--host-info") && argv[1] && !argv[2]) {
+        return 0;
+    }
+#endif /* XCODE_INTEGRATION */
+
     /* Things like "distcc -c hello.c" with an implied compiler are
      * handled earlier on by inserting a compiler name.  At this
      * point, argv[0] should always be a compiler name. */
     if (argv[0][0] == '-') {
         rs_log_error("unrecognized distcc option: %s", argv[0]);
         exit(EXIT_BAD_ARGUMENTS);
     }
 
@@ -206,19 +213,21 @@
                 seen_opt_s = 1;
             } else if (!strcmp(a, "-fprofile-arcs")
                        || !strcmp(a, "-ftest-coverage")) {
                 rs_log_info("compiler will emit profile info; must be local");
                 return EXIT_DISTCC_FAILED;
             } else if (!strcmp(a, "-frepo")) {
                 rs_log_info("compiler will emit .rpo files; must be local");
                 return EXIT_DISTCC_FAILED;
+#if 0
             } else if (str_startswith("-x", a)) {
                 rs_log_info("gcc's -x handling is complex; running locally");
                 return EXIT_DISTCC_FAILED;
+#endif
             } else if (str_startswith("-dr", a)) {
                 rs_log_info("gcc's debug option %s may write extra files; "
                             "running locally", a);
                 return EXIT_DISTCC_FAILED;
             } else if (!strcmp(a, "-c")) {
                 seen_opt_c = 1;
             } else if (!strcmp(a, "-o")) {
                 /* Whatever follows must be the output */
diff -U8 -r -N distcc-3.1.orig/src/compile.h distcc-3.1/src/compile.h
--- distcc-3.1.orig/src/compile.h	2008-12-02 16:50:25.000000000 -0500
+++ distcc-3.1/src/compile.h	2009-03-18 19:51:11.000000000 -0400
@@ -30,16 +30,20 @@
                        char *output_fname,
                        char *deps_fname,
                        char *server_stderr_fname,
                        pid_t cpp_pid,
                        int local_cpu_lock_fd,
                        struct dcc_hostdef *host,
                        int *status);
 
+#ifdef XCODE_INTEGRATION
+int dcc_show_host_info(char *host);
+#endif
+
 /* compile.c */
 
 extern int dcc_scan_includes;
 
 int dcc_build_somewhere_timed(char *argv[],
                               int sg_level,
                               int *status);
 
diff -U8 -r -N distcc-3.1.orig/src/distcc.c distcc-3.1/src/distcc.c
--- distcc-3.1.orig/src/distcc.c	2008-12-02 16:50:25.000000000 -0500
+++ distcc-3.1/src/distcc.c	2009-03-18 19:56:09.000000000 -0400
@@ -240,16 +240,23 @@
             goto out;
         }
 
         if (!strcmp(argv[1], "--scan-includes")) {
             dcc_scan_includes = 1;
             argv++;
         }
 
+#ifdef XCODE_INTEGRATION
+        if (!strcmp(argv[1], "--host-info") && argc == 3) {
+            ret = dcc_show_host_info(argv[2]);
+            goto out;
+        }
+#endif /* XCODE_INTEGRATION */
+
         if ((ret = dcc_find_compiler(argv, &compiler_args)) != 0) {
             goto out;
         }
         /* compiler_args is now respectively either "cc -c hello.c" or
          * "gcc -c hello.c" */
 
 #if 0
         /* I don't think we need to call this: if we reached this
diff -U8 -r -N distcc-3.1.orig/src/remote.c distcc-3.1/src/remote.c
--- distcc-3.1.orig/src/remote.c	2008-12-02 16:50:24.000000000 -0500
+++ distcc-3.1/src/remote.c	2009-03-18 20:21:16.000000000 -0400
@@ -307,8 +307,92 @@
      * when something possibly went wrong, and it allows us to account for the
      * cost of the ssh child. */
     if (ssh_pid) {
         dcc_collect_child("ssh", ssh_pid, &ssh_status, timeout_null_fd); /* ignore failure */
     }
 
     return ret;
 }
+
+
+#ifdef XCODE_INTEGRATION
+/**
+ * Print information about a host to stdout.
+ *
+ * This function connects to host, sends an HINF query, and prints the result.
+ * Xcode uses the output to determine various characteristics about the host,
+ * such as the hardware and operating system in use, the compilers available,
+ * and the number of CPUs available.  Only distccd servers built with Xcode
+ * integration support HINF.
+ *
+ * @param host The host to query.
+ *
+ * Returns 0 on success, otherwise error.  Returning nonzero does not
+ */
+int dcc_show_host_info(char *host)
+{
+    int to_net_fd = -1, from_net_fd = -1;
+    int ret;
+    pid_t ssh_pid = 0;
+    int ssh_status;
+    char *info;
+    struct dcc_hostdef *hostdef;
+    int n_hosts = 0;
+    const char *argv[] = { "--host-info", NULL };
+
+    if ((ret = dcc_parse_hosts(host, "command line",
+                               &hostdef, &n_hosts, NULL))) {
+        rs_log_error("bad host argument: %s", host);
+        return ret;
+    }
+
+    if (n_hosts != 1) {
+        rs_log_error("too many hosts for --host-info %s", host);
+        return EXIT_BAD_ARGUMENTS;
+    }
+
+    if ((ret = dcc_remote_connect(hostdef, &to_net_fd,
+                                  &from_net_fd, &ssh_pid))) {
+        rs_log_error("couldn't connect to %s", host);
+        printf("ERROR=%d\n", errno);
+        return ret;
+    }
+
+    if ((ret = dcc_send_header(to_net_fd, (char**)argv, hostdef)) != 0) {
+        rs_log_error("failed to send request");
+        printf("ERROR=%d\n", errno);
+        goto out;
+    }
+
+    if ((ret = dcc_r_result_header(from_net_fd, hostdef->protover)))
+        goto out; /* dcc_r_result_header logs its own error on failure */
+
+    if ((ret = dcc_r_token_string(from_net_fd, "HINF", &info))) {
+        rs_log_error("failed to read result");
+        printf("ERROR=%d\n", errno);
+    }
+
+  out:
+    /* Close socket so that the server can terminate, rather than
+     * making it wait until we've finished our work. */
+    if (to_net_fd != from_net_fd) {
+        if (to_net_fd != -1)
+            dcc_close(to_net_fd);
+    }
+    if (from_net_fd != -1)
+        dcc_close(from_net_fd);
+
+    /* Collect the SSH child.  Strictly this is unnecessary; it might slow the
+     * client down a little when things could otherwise be proceeding in the
+     * background.  But it helps make sure that we don't assume we succeeded
+     * when something possibly went wrong, and it allows us to account for the
+     * cost of the ssh child. */
+    if (ssh_pid) {
+        dcc_collect_child("ssh", ssh_pid, &ssh_status, timeout_null_fd); /* ignore failure */
+    }
+
+    if (!ret)
+        printf("%s\n", info);
+
+    return ret;
+}
+#endif /* XCODE_INTEGRATION */
